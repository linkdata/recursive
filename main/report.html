
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>recursive: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/recursive/cache.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/recursive/cachebucket.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/recursive/cachedneterror.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/recursive/cachemarshalling.go (93.8%)</option>
				
				<option value="file4">github.com/linkdata/recursive/cachevalue.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/recursive/comparemessage.go (69.3%)</option>
				
				<option value="file6">github.com/linkdata/recursive/cookie.go (100.0%)</option>
				
				<option value="file7">github.com/linkdata/recursive/disable.go (100.0%)</option>
				
				<option value="file8">github.com/linkdata/recursive/extendedrcode.go (100.0%)</option>
				
				<option value="file9">github.com/linkdata/recursive/ioutil.go (100.0%)</option>
				
				<option value="file10">github.com/linkdata/recursive/mismatchedquestionerror.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/recursive/orderroots.go (100.0%)</option>
				
				<option value="file12">github.com/linkdata/recursive/query.go (89.2%)</option>
				
				<option value="file13">github.com/linkdata/recursive/recursive.go (100.0%)</option>
				
				<option value="file14">github.com/linkdata/recursive/timeroot.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package recursive

import (
        "context"
        "math"
        "net/netip"
        "sync/atomic"
        "time"

        "github.com/miekg/dns"
)

const DefaultMinTTL = 10
const DefaultMaxTTL = 7 * 24 * 60 * 60
const DefaultNXTTL = 60 * 60
const cacheBucketCountBits = 5
const cacheBucketCount = (1 &lt;&lt; cacheBucketCountBits)

type Cache struct {
        MinTTL uint32 // always cache responses for at least this long seconds
        MaxTTL uint32 // never cache responses for longer than this seconds (excepting successful NS responses)
        NXTTL  uint32 // cache NXDOMAIN responses for this long seconds
        count  atomic.Uint64
        hits   atomic.Uint64
        cq     [cacheBucketCount]*cacheBucket
}

var _ CachingResolver = &amp;Cache{}

func NewCache() *Cache <span class="cov3" title="54">{
        cache := &amp;Cache{
                MinTTL: DefaultMinTTL,
                MaxTTL: DefaultMaxTTL,
                NXTTL:  DefaultNXTTL,
        }
        for i := range cache.cq </span><span class="cov5" title="1728">{
                cache.cq[i] = newCacheBucket()
        }</span>
        <span class="cov3" title="54">return cache</span>
}

// HitRatio returns the hit ratio as a percentage.
func (cache *Cache) HitRatio() (n float64) <span class="cov1" title="5">{
        if cache != nil </span><span class="cov1" title="5">{
                if count := cache.count.Load(); count &gt; 0 </span><span class="cov1" title="5">{
                        n = float64(cache.hits.Load()*100) / float64(count)
                }</span>
        }
        <span class="cov1" title="5">return</span>
}

// Entries returns the number of entries in the cache.
func (cache *Cache) Entries() (n int) <span class="cov2" title="24">{
        if cache != nil </span><span class="cov2" title="24">{
                for _, cq := range cache.cq </span><span class="cov4" title="768">{
                        n += cq.entries()
                }</span>
        }
        <span class="cov2" title="24">return</span>
}

func newBucketKey(qname string, qtype uint16) (key bucketKey) <span class="cov10" title="5001580">{
        key = bucketKey{qname: qname, qtype: qtype}
        return
}</span>

func (cache *Cache) bucketFor(key bucketKey) (bucket *cacheBucket) <span class="cov9" title="2000906">{
        bucket = cache.cq[bucketIndexForQname(key.qname)]
        return
}</span>

// DnsSet add a DNS message to the cache.
//
// Does nothing if the message has the Zero flag set, or does not have exactly one Question.
func (cache *Cache) DnsSet(msg *dns.Msg) <span class="cov9" title="2000391">{
        if cache != nil &amp;&amp; msg != nil &amp;&amp; !msg.Zero &amp;&amp; len(msg.Question) == 1 </span><span class="cov9" title="2000391">{
                question := msg.Question[0]
                key := newBucketKey(question.Name, question.Qtype)
                msg = msg.Copy()
                msg.Zero = true
                ttl := cache.NXTTL
                if msg.Rcode != dns.RcodeNameError </span><span class="cov9" title="2000382">{
                        ttl = max(cache.MinTTL, minDNSMsgTTL(msg))
                        if question.Qtype != dns.TypeNS || msg.Rcode != dns.RcodeSuccess </span><span class="cov9" title="1933618">{
                                ttl = min(cache.MaxTTL, ttl)
                        }</span>
                }
                <span class="cov9" title="2000391">cache.bucketFor(key).set(msg, time.Now().Unix()+int64(ttl))</span>
        }
}

// DnsGet returns a caches DNS message if one exists that has not expired.
//
// If an expired message is found, it is removed from the cache and nil is returned.
func (cache *Cache) DnsGet(qname string, qtype uint16) (msg *dns.Msg) <span class="cov4" title="478">{
        msg, _ = cache.Get(qname, qtype, nil)
        return
}</span>

func defaultAllowFn(msg *dns.Msg, ttl time.Duration) bool <span class="cov4" title="365">{
        return ttl &gt; 0
}</span>

// Get allows filtering DNS entries from the cache and control of eviction.
//
// If and entry is found, and allowfn returns true, the entry is returned.
// Otherwise, the entry is purged from the cache,
//
// The default allowfn returns false if the entry is stale.
func (cache *Cache) Get(qname string, qtype uint16, allowfn func(msg *dns.Msg, ttl time.Duration) bool) (msg *dns.Msg, stale bool) <span class="cov4" title="481">{
        if cache != nil </span><span class="cov4" title="481">{
                if allowfn == nil </span><span class="cov4" title="478">{
                        allowfn = defaultAllowFn
                }</span>
                <span class="cov4" title="481">cache.count.Add(1)
                key := newBucketKey(qname, qtype)
                if msg, stale = cache.bucketFor(key).get(key, allowfn); msg != nil </span><span class="cov4" title="363">{
                        cache.hits.Add(1)
                }</span>
        }
        <span class="cov4" title="481">return</span>
}

func (cache *Cache) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov1" title="1">{
        msg = cache.DnsGet(qname, qtype)
        return
}</span>

// CleanAllow calls allowfn with 't' as the time to use to determine staleness.
// If allowfn returns false, the cache entry is removed.
func (cache *Cache) CleanAllow(t time.Time, allowfn func(msg *dns.Msg, ttl time.Duration) bool) <span class="cov2" title="16">{
        if cache != nil </span><span class="cov2" title="16">{
                for _, cq := range cache.cq </span><span class="cov4" title="512">{
                        cq.clean(t, allowfn)
                }</span>
        }
}

// CleanBefore removes entries that expired before t from the cache.
func (cache *Cache) CleanBefore(t time.Time) <span class="cov1" title="2">{
        cache.CleanAllow(t, defaultAllowFn)
}</span>

// Clean removes stale entries from the cache.
func (cache *Cache) Clean() <span class="cov1" title="1">{
        cache.CleanBefore(time.Now())
}</span>

func (cache *Cache) Clear() <span class="cov2" title="14">{
        cache.CleanAllow(time.Time{}, func(msg *dns.Msg, ttl time.Duration) bool </span><span class="cov1" title="1">{ return false }</span>)
}

// Merge inserts all entries from other into cache.
// If an entry exists in both, the one that expires last wins.
func (cache *Cache) Merge(other *Cache) <span class="cov1" title="4">{
        if cache != nil &amp;&amp; other != nil &amp;&amp; cache != other </span><span class="cov1" title="4">{
                type mergeEntry struct {
                        key bucketKey
                        cv  cacheValue
                }
                for i := range other.cq </span><span class="cov3" title="128">{
                        var entries []mergeEntry
                        other.cq[i].mu.RLock()
                        for key, cv := range other.cq[i].cache </span><span class="cov1" title="2">{
                                entries = append(entries, mergeEntry{key: key, cv: cv})
                        }</span>
                        <span class="cov3" title="128">other.cq[i].mu.RUnlock()
                        if len(entries) &gt; 0 </span><span class="cov1" title="2">{
                                cache.cq[i].mu.Lock()
                                for _, entry := range entries </span><span class="cov1" title="2">{
                                        if oldcv, ok := cache.cq[i].cache[entry.key]; !ok || entry.cv.expires &gt; oldcv.expires </span><span class="cov1" title="2">{
                                                cache.cq[i].cache[entry.key] = entry.cv
                                        }</span>
                                }
                                <span class="cov1" title="2">cache.cq[i].mu.Unlock()</span>
                        }
                }
        }
}

// Walk calls fn for each entry in the cache. If fn returns an error, it stops and returns that error.
func (cache *Cache) Walk(fn func(msg *dns.Msg, expires time.Time) (err error)) (err error) <span class="cov1" title="2">{
        if cache != nil &amp;&amp; fn != nil </span><span class="cov1" title="2">{
                for _, qc := range cache.cq </span><span class="cov3" title="51">{
                        var cvs []cacheValue
                        qc.mu.RLock()
                        for _, cv := range qc.cache </span><span class="cov1" title="3">{
                                cvs = append(cvs, cv)
                        }</span>
                        <span class="cov3" title="51">qc.mu.RUnlock()
                        for _, cv := range cvs </span><span class="cov1" title="3">{
                                if err = fn(cv.Msg, cv.expiresAt()); err != nil </span><span class="cov1" title="1">{
                                        return
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func minDNSMsgTTL(msg *dns.Msg) (minTTL uint32) <span class="cov9" title="2000745">{
        minTTL = math.MaxUint32
        if msg != nil </span><span class="cov9" title="2000745">{
                for _, rr := range msg.Answer </span><span class="cov9" title="2000374">{
                        if rr != nil </span><span class="cov9" title="2000374">{
                                minTTL = min(minTTL, rr.Header().Ttl)
                        }</span>
                }
                <span class="cov9" title="2000745">for _, rr := range msg.Ns </span><span class="cov5" title="1971">{
                        if rr != nil </span><span class="cov5" title="1971">{
                                minTTL = min(minTTL, rr.Header().Ttl)
                        }</span>
                }
                <span class="cov9" title="2000745">for _, rr := range msg.Extra </span><span class="cov5" title="3771">{
                        if rr != nil </span><span class="cov5" title="3771">{
                                if rr.Header().Rrtype != dns.TypeOPT </span><span class="cov5" title="3356">{
                                        minTTL = min(minTTL, rr.Header().Ttl)
                                }</span>
                        }
                }
        }
        <span class="cov9" title="2000745">if minTTL == math.MaxUint32 </span><span class="cov3" title="47">{
                minTTL = 0
        }</span>
        <span class="cov9" title="2000745">return</span>
}

func clampMessageTTL(msg *dns.Msg, ttlSeconds uint32) <span class="cov4" title="292">{
        for _, rr := range msg.Answer </span><span class="cov3" title="60">{
                clampRRHeaderTTL(rr, ttlSeconds)
        }</span>
        <span class="cov4" title="292">for _, rr := range msg.Ns </span><span class="cov5" title="1580">{
                clampRRHeaderTTL(rr, ttlSeconds)
        }</span>
        <span class="cov4" title="292">for _, rr := range msg.Extra </span><span class="cov5" title="3142">{
                clampRRHeaderTTL(rr, ttlSeconds)
        }</span>
}

func clampRRHeaderTTL(rr dns.RR, ttlSeconds uint32) <span class="cov5" title="4782">{
        if hdr := rr.Header(); hdr.Rrtype != dns.TypeOPT </span><span class="cov5" title="4500">{
                if hdr.Ttl &gt; ttlSeconds </span><span class="cov5" title="4500">{
                        hdr.Ttl = ttlSeconds
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package recursive

import (
        "hash/maphash"
        "sync"
        "time"

        "github.com/miekg/dns"
)

type bucketKey struct {
        qname string
        qtype uint16
}

type cacheBucket struct {
        mu    sync.RWMutex
        cache map[bucketKey]cacheValue
}

func newCacheBucket() *cacheBucket <span class="cov5" title="1728">{
        return &amp;cacheBucket{cache: make(map[bucketKey]cacheValue)}
}</span>

var bucketSeed = maphash.MakeSeed()

func bucketIndexForQname(qname string) (idx int) <span class="cov10" title="3001169">{
        idx = int(maphash.String(bucketSeed, qname) &amp; (cacheBucketCount - 1)) // #nosec G115
        return
}</span>

func (cq *cacheBucket) entries() (n int) <span class="cov5" title="768">{
        cq.mu.RLock()
        n = len(cq.cache)
        cq.mu.RUnlock()
        return
}</span>

func questionBucketKey(q dns.Question) bucketKey <span class="cov9" title="3000677">{
        return newBucketKey(q.Name, q.Qtype)
}</span>

func (cq *cacheBucket) setLocked(msg *dns.Msg, expires int64) <span class="cov9" title="3000677">{
        cq.cache[questionBucketKey(msg.Question[0])] = cacheValue{Msg: msg, expires: expires}
}</span>

func (cq *cacheBucket) set(msg *dns.Msg, expires int64) <span class="cov9" title="2000414">{
        cq.mu.Lock()
        cq.setLocked(msg, expires)
        cq.mu.Unlock()
}</span>

func (cq *cacheBucket) get(key bucketKey, allowfn func(msg *dns.Msg, ttl time.Duration) bool) (msg *dns.Msg, stale bool) <span class="cov4" title="481">{
        cq.mu.RLock()
        cv := cq.cache[key]
        cq.mu.RUnlock()
        if cv.Msg != nil </span><span class="cov4" title="366">{
                ttl := time.Until(cv.expiresAt())
                stale = ttl &lt; 0
                if allowfn(cv.Msg, ttl) </span><span class="cov4" title="363">{
                        msg = cv.Msg
                        clampTTL := clampTTLSeconds(ttl)
                        if minDNSMsgTTL(msg) &gt; clampTTL </span><span class="cov4" title="292">{
                                msg = cv.Copy()
                                clampMessageTTL(msg, clampTTL)
                        }</span>
                } else<span class="cov1" title="3"> {
                        cq.mu.Lock()
                        if current, ok := cq.cache[key]; ok </span><span class="cov1" title="3">{
                                if current.Msg == cv.Msg </span><span class="cov1" title="2">{
                                        delete(cq.cache, key)
                                }</span>
                        }
                        <span class="cov1" title="3">cq.mu.Unlock()</span>
                }
        }
        <span class="cov4" title="481">return</span>
}

func (cq *cacheBucket) cleanLocked(t time.Time, allowfn func(msg *dns.Msg, ttl time.Duration) bool) <span class="cov4" title="512">{
        for key, cv := range cq.cache </span><span class="cov1" title="3">{
                if !allowfn(cv.Msg, cv.expiresAt().Sub(t)) </span><span class="cov1" title="3">{
                        delete(cq.cache, key)
                }</span>
        }
}

func (cq *cacheBucket) clean(t time.Time, allowfn func(msg *dns.Msg, ttl time.Duration) bool) <span class="cov4" title="512">{
        cq.mu.Lock()
        defer cq.mu.Unlock()
        cq.cleanLocked(t, allowfn)
}</span>

func clampTTLSeconds(ttl time.Duration) (secs uint32) <span class="cov4" title="363">{
        if ttl &gt; 0 </span><span class="cov4" title="362">{
                secs = ^uint32(0)
                if ttl &lt;= time.Duration(^uint32(0))*time.Second </span><span class="cov4" title="362">{
                        secs = uint32(ttl / time.Second) // #nosec G115
                }</span>
        }
        <span class="cov4" title="363">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package recursive

import (
        "fmt"
        "net/netip"
        "time"
)

type CachedNetError struct {
        When     time.Time
        Err      error
        Protocol string
        Address  netip.Addr
}

func (ne *CachedNetError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("(cached) %v %v: %v", ne.Protocol, ne.Address, ne.Err.Error())
}</span>

func (ne *CachedNetError) Unwrap() error <span class="cov8" title="1">{
        return ne.Err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package recursive

import (
        "encoding/binary"
        "errors"
        "io"
        "sync"
)

var ErrWrongMagic = errors.New("wrong magic number")
var ErrInvalidCacheEntry = errors.New("invalid cache entry")
var ErrCacheEntryTooLarge = errors.New("cache entry too large")

const cacheMagic = int64(0xCACE0003)
const marshalWorkerBufferSize = 1024 * 8
const maxCacheEntrySize = int(^uint16(0))

func (cache *Cache) lockAll() <span class="cov2" title="26">{
        for _, cq := range cache.cq </span><span class="cov5" title="832">{
                cq.mu.Lock()
        }</span>
}

func (cache *Cache) unlockAll() <span class="cov2" title="26">{
        for _, cq := range cache.cq </span><span class="cov5" title="832">{
                cq.mu.Unlock()
        }</span>
}

func (cache *Cache) WriteTo(w io.Writer) (n int64, err error) <span class="cov2" title="14">{
        if cache != nil </span><span class="cov2" title="14">{
                cache.lockAll()
                defer cache.unlockAll()
                err = cache.writeToLocked(w, &amp;n)
        }</span>
        <span class="cov2" title="14">return</span>
}

func (cache *Cache) ReadFrom(r io.Reader) (n int64, err error) <span class="cov2" title="12">{
        if cache != nil </span><span class="cov2" title="12">{
                var gotmagic int64
                if gotmagic, err = readInt64(r, &amp;n); err == nil </span><span class="cov2" title="12">{
                        err = ErrWrongMagic
                        if gotmagic == cacheMagic </span><span class="cov2" title="12">{
                                err = cache.readFrom(r, &amp;n)
                        }</span>
                }
        }
        <span class="cov2" title="12">return</span>
}

func marshalWorker(qc *cacheBucket, w io.Writer, n *int64, perr *error, pmu *sync.Mutex, wg *sync.WaitGroup) <span class="cov4" title="416">{
        defer wg.Done()
        var buf []byte
        wf := func() (fatal bool) </span><span class="cov7" title="39529">{
                pmu.Lock()
                defer pmu.Unlock()
                written, err := writeAll(w, buf)
                *n += int64(written)
                if err != nil </span><span class="cov0" title="0">{
                        fatal = (err == io.EOF || errors.Is(err, io.ErrShortWrite))
                        *perr = errors.Join(*perr, err)
                }</span>
                <span class="cov7" title="39529">buf = buf[:0]
                return</span>
        }
        <span class="cov4" title="416">for _, cv := range qc.cache </span><span class="cov10" title="3000264">{
                if b, err := cv.MarshalBinary(); err == nil </span><span class="cov9" title="3000263">{
                        if len(b) &gt; maxCacheEntrySize </span><span class="cov1" title="1">{
                                pmu.Lock()
                                *perr = errors.Join(*perr, ErrCacheEntryTooLarge)
                                pmu.Unlock()
                        }</span> else<span class="cov9" title="3000262"> if len(b) &gt; 0 </span><span class="cov9" title="3000262">{
                                if len(buf)+2+len(b) &gt; marshalWorkerBufferSize </span><span class="cov7" title="39113">{
                                        if wf() </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                                <span class="cov9" title="3000262">buf = binary.BigEndian.AppendUint16(buf, uint16(len(b))) // #nosec G115
                                buf = append(buf, b...)</span>
                        }
                } else<span class="cov1" title="1"> {
                        pmu.Lock()
                        *perr = errors.Join(*perr, err)
                        pmu.Unlock()
                }</span>
        }
        <span class="cov4" title="416">wf()</span>
}

func (cache *Cache) writeToLocked(w io.Writer, n *int64) (err error) <span class="cov2" title="14">{
        if err = writeInt64(w, n, cacheMagic); err == nil </span><span class="cov2" title="13">{
                var wg sync.WaitGroup
                var mu sync.Mutex
                for _, cq := range cache.cq </span><span class="cov4" title="416">{
                        wg.Add(1)
                        go marshalWorker(cq, w, n, &amp;err, &amp;mu, &amp;wg)
                }</span>
                <span class="cov2" title="13">wg.Wait()</span>
        }
        <span class="cov2" title="14">return</span>
}

func (cache *Cache) readFrom(r io.Reader, n *int64) (err error) <span class="cov2" title="12">{
        cache.Clear()
        cache.lockAll()
        defer cache.unlockAll()
        var readerr error
        buf := make([]byte, 512)
        for readerr == nil </span><span class="cov9" title="1000276">{
                var numread int
                numread, readerr = io.ReadFull(r, buf[:2])
                *n += int64(numread)
                if readerr == nil </span><span class="cov9" title="1000264">{
                        length := int(binary.BigEndian.Uint16(buf[:2]))
                        if length &gt; 0 </span><span class="cov9" title="1000264">{
                                if length &gt; cap(buf) </span><span class="cov0" title="0">{
                                        buf = make([]byte, length)
                                }</span>
                                <span class="cov9" title="1000264">buf = buf[:length]
                                numread, readerr = io.ReadFull(r, buf)
                                *n += int64(numread)
                                if readerr == nil </span><span class="cov9" title="1000264">{
                                        var cv cacheValue
                                        if merr := cv.UnmarshalBinary(buf); merr == nil </span><span class="cov9" title="1000264">{
                                                // the cache is explicitly allowed to contain expired entries
                                                // but may not contain entries without questions
                                                if cv.Msg != nil &amp;&amp; len(cv.Question) &gt; 0 </span><span class="cov9" title="1000263">{
                                                        cache.cq[cv.bucketIndex()].setLocked(cv.Msg, cv.expires)
                                                }</span> else<span class="cov1" title="1"> {
                                                        err = errors.Join(err, ErrInvalidCacheEntry)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                err = errors.Join(err, merr)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="12">if readerr == io.EOF </span><span class="cov2" title="12">{
                readerr = nil
        }</span>
        <span class="cov2" title="12">err = errors.Join(err, readerr)
        return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package recursive

import (
        "encoding/binary"
        "io"
        "time"

        "github.com/miekg/dns"
)

type cacheValue struct {
        *dns.Msg       // the message (with Zero flag set)
        expires  int64 // expiry Unix time
}

func (cv cacheValue) expiresAt() time.Time <span class="cov4" title="372">{
        return time.Unix(cv.expires, 0)
}</span>

func (cv *cacheValue) MarshalBinary() (b []byte, err error) <span class="cov10" title="3000495">{
        var packed []byte
        if packed, err = cv.Pack(); err == nil </span><span class="cov9" title="3000494">{
                b = binary.AppendVarint(b, cv.expires)
                b = append(b, packed...)
        }</span>
        <span class="cov10" title="3000495">return</span>
}

func (cv *cacheValue) UnmarshalBinary(b []byte) (err error) <span class="cov9" title="1000264">{
        err = io.ErrShortBuffer
        if expiry, n := binary.Varint(b); n &gt; 0 </span><span class="cov9" title="1000264">{
                var msg dns.Msg
                if err = msg.Unpack(b[n:]); err == nil </span><span class="cov9" title="1000264">{
                        cv.Msg = &amp;msg
                        cv.expires = expiry
                }</span>
        }
        <span class="cov9" title="1000264">return</span>
}

func (cv *cacheValue) bucketIndex() int <span class="cov9" title="1000263">{
        return bucketIndexForQname(cv.Question[0].Name)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package recursive

import (
        "fmt"
        "io"
        "sort"
        "strings"

        "github.com/miekg/dns"
)

type comparableSections struct {
        answer    []dns.RR
        authority []dns.RR
        extra     []dns.RR
}

// CompareMessage compares two DNS messages and returns ordering information.
//
// It compares the response code and records in Answer, Authority, and Extra.
// Differences in TTL values, OPT pseudo-records, and record ordering are
// ignored. Any discovered differences are written as plain text to w.
//
// Return values:
//   - -1 if a has less data than b
//   - +1 if a has more data than b
//   - 0 if the messages are equivalent
func CompareMessage(a, b *dns.Msg, w io.Writer) (cmp int) <span class="cov5" title="9">{
        out := io.Discard
        if w != nil </span><span class="cov3" title="3">{
                out = w
        }</span>

        <span class="cov5" title="9">aSections := newComparableSections(a)
        bSections := newComparableSections(b)

        equivalent := true
        if !compareRcode(a, b, out) </span><span class="cov3" title="3">{
                equivalent = false
        }</span>
        <span class="cov5" title="9">if !compareSectionRRs("answer", aSections.answer, bSections.answer, out) </span><span class="cov5" title="7">{
                equivalent = false
        }</span>
        <span class="cov5" title="9">if !compareSectionRRs("authority", aSections.authority, bSections.authority, out) </span><span class="cov1" title="1">{
                equivalent = false
        }</span>
        <span class="cov5" title="9">if !compareSectionRRs("extra", aSections.extra, bSections.extra, out) </span><span class="cov0" title="0">{
                equivalent = false
        }</span>
        <span class="cov5" title="9">if !equivalent </span><span class="cov5" title="7">{
                cmp = compareMessageOrdering(a, b, aSections, bSections)
        }</span>
        <span class="cov5" title="9">return</span>
}

func compareRcode(a, b *dns.Msg, w io.Writer) (equivalent bool) <span class="cov5" title="9">{
        equivalent = true
        if a != nil || b != nil </span><span class="cov5" title="8">{
                if a == nil || b == nil </span><span class="cov2" title="2">{
                        equivalent = false
                }</span> else<span class="cov5" title="6"> {
                        equivalent = a.Rcode == b.Rcode
                }</span>
                <span class="cov5" title="8">if !equivalent </span><span class="cov3" title="3">{
                        _, _ = fmt.Fprintf(w, "rcode differs: a=%s b=%s\n", messageRcodeString(a), messageRcodeString(b))
                }</span>
        }
        <span class="cov5" title="9">return</span>
}

func compareSectionRRs(section string, a, b []dns.RR, w io.Writer) (equivalent bool) <span class="cov8" title="27">{
        unmatchedB := append([]dns.RR(nil), b...)
        equivalent = true

        for _, aRR := range a </span><span class="cov6" title="12">{
                matchIdx := matchingRRIndex(aRR, unmatchedB)
                if matchIdx &gt;= 0 </span><span class="cov5" title="6">{
                        unmatchedB = append(unmatchedB[:matchIdx], unmatchedB[matchIdx+1:]...)
                }</span> else<span class="cov5" title="6"> {
                        equivalent = false
                        _, _ = fmt.Fprintf(w, "%s only in a: %s\n", section, rrText(aRR))
                }</span>
        }

        <span class="cov8" title="27">for _, bRR := range unmatchedB </span><span class="cov5" title="6">{
                equivalent = false
                _, _ = fmt.Fprintf(w, "%s only in b: %s\n", section, rrText(bRR))
        }</span>

        <span class="cov8" title="27">return</span>
}

func compareMessageOrdering(a, b *dns.Msg, aSections, bSections comparableSections) (cmp int) <span class="cov5" title="7">{
        aDataCount := len(aSections.answer) + len(aSections.authority) + len(aSections.extra)
        bDataCount := len(bSections.answer) + len(bSections.authority) + len(bSections.extra)
        cmp = compareInt(aDataCount, bDataCount)
        if cmp == 0 </span><span class="cov3" title="3">{
                cmp = compareInt(messageRcodeValue(a), messageRcodeValue(b))
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareInt(len(aSections.answer), len(bSections.answer))
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareInt(len(aSections.authority), len(bSections.authority))
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareInt(len(aSections.extra), len(bSections.extra))
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareMsgHdrWithoutRcode(a, b)
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareRRLists(aSections.answer, bSections.answer)
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareRRLists(aSections.authority, bSections.authority)
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareRRLists(aSections.extra, bSections.extra)
        }</span>
        <span class="cov5" title="7">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareQuestionLists(msgQuestion(a), msgQuestion(b))
        }</span>
        <span class="cov5" title="7">return</span>
}

func compareMsgHdrWithoutRcode(a, b *dns.Msg) (cmp int) <span class="cov2" title="2">{
        hdrA := messageHdr(a)
        hdrB := messageHdr(b)
        cmp = compareUint16(hdrA.Id, hdrB.Id)
        if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareBool(hdrA.Response, hdrB.Response)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareInt(hdrA.Opcode, hdrB.Opcode)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov2" title="2">{
                cmp = compareBool(hdrA.Authoritative, hdrB.Authoritative)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.Truncated, hdrB.Truncated)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.RecursionDesired, hdrB.RecursionDesired)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.RecursionAvailable, hdrB.RecursionAvailable)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.Zero, hdrB.Zero)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.AuthenticatedData, hdrB.AuthenticatedData)
        }</span>
        <span class="cov2" title="2">if cmp == 0 </span><span class="cov0" title="0">{
                cmp = compareBool(hdrA.CheckingDisabled, hdrB.CheckingDisabled)
        }</span>
        <span class="cov2" title="2">return</span>
}

func compareRRLists(a, b []dns.RR) (cmp int) <span class="cov0" title="0">{
        keysA := rrKeys(a)
        keysB := rrKeys(b)
        cmp = compareInt(len(keysA), len(keysB))
        if cmp == 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(keysA) &amp;&amp; cmp == 0; i++ </span><span class="cov0" title="0">{
                        cmp = strings.Compare(keysA[i], keysB[i])
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func rrKeys(rrs []dns.RR) (keys []string) <span class="cov0" title="0">{
        keys = make([]string, 0, len(rrs))
        for _, rr := range rrs </span><span class="cov0" title="0">{
                keys = append(keys, rrKey(rr))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return</span>
}

func rrKey(rr dns.RR) (key string) <span class="cov0" title="0">{
        key = "&lt;nil&gt;"
        if rr != nil </span><span class="cov0" title="0">{
                rrCopy := dns.Copy(rr)
                if rrCopy != nil </span><span class="cov0" title="0">{
                        hdr := rrCopy.Header()
                        if hdr != nil </span><span class="cov0" title="0">{
                                hdr.Ttl = 0
                        }</span>
                        <span class="cov0" title="0">rrLen := dns.Len(rrCopy)
                        if rrLen &gt; 0 </span><span class="cov0" title="0">{
                                wire := make([]byte, rrLen)
                                off, err := dns.PackRR(rrCopy, wire, 0, nil, false)
                                if err == nil &amp;&amp; off &gt; 0 </span><span class="cov0" title="0">{
                                        key = string(wire[:off])
                                }</span> else<span class="cov0" title="0"> {
                                        key = rrCopy.String()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                key = rrCopy.String()
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func compareQuestionLists(a, b []dns.Question) (cmp int) <span class="cov0" title="0">{
        keysA := questionKeys(a)
        keysB := questionKeys(b)
        cmp = compareInt(len(keysA), len(keysB))
        if cmp == 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(keysA) &amp;&amp; cmp == 0; i++ </span><span class="cov0" title="0">{
                        cmp = strings.Compare(keysA[i], keysB[i])
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func questionKeys(questions []dns.Question) (keys []string) <span class="cov0" title="0">{
        keys = make([]string, 0, len(questions))
        for _, question := range questions </span><span class="cov0" title="0">{
                keys = append(keys, fmt.Sprintf("%s|%d|%d", dns.CanonicalName(question.Name), question.Qtype, question.Qclass))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        return</span>
}

func compareInt(a, b int) (cmp int) <span class="cov7" title="22">{
        if a &lt; b </span><span class="cov4" title="4">{
                cmp = -1
        }</span> else<span class="cov7" title="18"> {
                if a &gt; b </span><span class="cov3" title="3">{
                        cmp = 1
                }</span>
        }
        <span class="cov7" title="22">return</span>
}

func compareUint16(a, b uint16) (cmp int) <span class="cov2" title="2">{
        if a &lt; b </span><span class="cov0" title="0">{
                cmp = -1
        }</span> else<span class="cov2" title="2"> {
                if a &gt; b </span><span class="cov0" title="0">{
                        cmp = 1
                }</span>
        }
        <span class="cov2" title="2">return</span>
}

func compareBool(a, b bool) (cmp int) <span class="cov4" title="4">{
        cmp = compareInt(boolToInt(a), boolToInt(b))
        return
}</span>

func boolToInt(v bool) (n int) <span class="cov5" title="8">{
        if v </span><span class="cov2" title="2">{
                n = 1
        }</span>
        <span class="cov5" title="8">return</span>
}

func messageHdr(msg *dns.Msg) (hdr dns.MsgHdr) <span class="cov4" title="4">{
        if msg != nil </span><span class="cov4" title="4">{
                hdr = msg.MsgHdr
        }</span>
        <span class="cov4" title="4">return</span>
}

func messageRcodeValue(msg *dns.Msg) (rcode int) <span class="cov5" title="6">{
        rcode = -1
        if msg != nil </span><span class="cov5" title="6">{
                rcode = msg.Rcode
        }</span>
        <span class="cov5" title="6">return</span>
}

func newComparableSections(msg *dns.Msg) (sections comparableSections) <span class="cov7" title="18">{
        sections.answer = comparableRRs(msgAnswer(msg))
        sections.authority = comparableRRs(msgAuthority(msg))
        sections.extra = comparableRRs(msgExtra(msg))
        return
}</span>

func comparableRRs(rrs []dns.RR) (out []dns.RR) <span class="cov10" title="54">{
        out = make([]dns.RR, 0, len(rrs))
        for _, rr := range rrs </span><span class="cov8" title="26">{
                include := true
                if rr != nil </span><span class="cov8" title="26">{
                        hdr := rr.Header()
                        if hdr != nil </span><span class="cov8" title="26">{
                                include = hdr.Rrtype != dns.TypeOPT
                        }</span>
                }
                <span class="cov8" title="26">if include </span><span class="cov8" title="24">{
                        out = append(out, rr)
                }</span>
        }
        <span class="cov10" title="54">return</span>
}

func matchingRRIndex(target dns.RR, candidates []dns.RR) (idx int) <span class="cov6" title="12">{
        idx = -1
        for i, candidate := range candidates </span><span class="cov6" title="11">{
                if rrsEquivalent(target, candidate) </span><span class="cov5" title="6">{
                        idx = i
                        break</span>
                }
        }
        <span class="cov6" title="12">return</span>
}

func rrsEquivalent(a, b dns.RR) (equivalent bool) <span class="cov6" title="11">{
        if a == nil || b == nil </span><span class="cov0" title="0">{
                equivalent = a == b
        }</span> else<span class="cov6" title="11"> {
                equivalent = dns.IsDuplicate(a, b)
        }</span>
        <span class="cov6" title="11">return</span>
}

func rrText(rr dns.RR) (s string) <span class="cov6" title="12">{
        s = "&lt;nil&gt;"
        if rr != nil </span><span class="cov6" title="12">{
                s = rr.String()
        }</span>
        <span class="cov6" title="12">return</span>
}

func messageRcodeString(msg *dns.Msg) (s string) <span class="cov5" title="6">{
        s = "&lt;nil&gt;"
        if msg != nil </span><span class="cov4" title="4">{
                s = dns.RcodeToString[msg.Rcode]
                if s == "" </span><span class="cov0" title="0">{
                        s = fmt.Sprintf("RCODE(%d)", msg.Rcode)
                }</span>
        }
        <span class="cov5" title="6">return</span>
}

func msgAnswer(msg *dns.Msg) (answer []dns.RR) <span class="cov7" title="18">{
        if msg != nil </span><span class="cov6" title="14">{
                answer = msg.Answer
        }</span>
        <span class="cov7" title="18">return</span>
}

func msgAuthority(msg *dns.Msg) (authority []dns.RR) <span class="cov7" title="18">{
        if msg != nil </span><span class="cov6" title="14">{
                authority = msg.Ns
        }</span>
        <span class="cov7" title="18">return</span>
}

func msgExtra(msg *dns.Msg) (extra []dns.RR) <span class="cov7" title="18">{
        if msg != nil </span><span class="cov6" title="14">{
                extra = msg.Extra
        }</span>
        <span class="cov7" title="18">return</span>
}

func msgQuestion(msg *dns.Msg) (questions []dns.Question) <span class="cov0" title="0">{
        if msg != nil </span><span class="cov0" title="0">{
                questions = msg.Question
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package recursive

import (
        crand "crypto/rand"
        "encoding/binary"
        "fmt"
        rand "math/rand/v2"
        "net/netip"
        "sort"
        "time"
)

var crandRead func(b []byte) (n int, err error) = crand.Read

type srvCookie struct {
        value string
        ts    time.Time
}

func makeCookie() string <span class="cov6" title="1020">{
        var b [8]byte
        n, _ := crandRead(b[:])
        x := binary.LittleEndian.Uint64(b[:])
        if n &lt; len(b) </span><span class="cov6" title="1020">{
                x ^= rand.Uint64() // #nosec G404
        }</span>
        <span class="cov6" title="1020">return fmt.Sprintf("%016x", x)</span>
}

func maskCookie(s string) string <span class="cov2" title="10">{
        if len(s) &gt; 5 </span><span class="cov2" title="9">{
                return "..." + s[len(s)-5:]
        }</span>
        <span class="cov1" title="1">return s</span>
}

// ResetCookies generates a new DNS client cookie and clears the known DNS server cookies.
func (r *Recursive) ResetCookies() <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.clicookie = makeCookie()
        clear(r.srvcookies)
}</span>

func (r *Recursive) cleanupSrvCookiesLocked(now time.Time) <span class="cov2" title="9">{
        cutoff := now.Add(-srvCookieTTL)
        for addr, c := range r.srvcookies </span><span class="cov7" title="8195">{
                if c.ts.Before(cutoff) </span><span class="cov1" title="1">{
                        delete(r.srvcookies, addr)
                }</span>
        }
        <span class="cov2" title="9">if len(r.srvcookies) &lt;= maxSrvCookies </span><span class="cov2" title="8">{
                return
        }</span>
        <span class="cov1" title="1">type ac struct {
                addr netip.Addr
                ts   time.Time
        }
        l := make([]ac, 0, len(r.srvcookies))
        for addr, c := range r.srvcookies </span><span class="cov7" title="8193">{
                l = append(l, ac{addr: addr, ts: c.ts})
        }</span>
        <span class="cov1" title="1">sort.Slice(l, func(i, j int) bool </span><span class="cov10" title="113787">{ return l[i].ts.Before(l[j].ts) }</span>)
        <span class="cov1" title="1">for i := 0; len(r.srvcookies) &gt; maxSrvCookies &amp;&amp; i &lt; len(l); i++ </span><span class="cov1" title="1">{
                delete(r.srvcookies, l[i].addr)
        }</span>
}

func (r *Recursive) cleanupSrvCookies(now time.Time) <span class="cov2" title="7">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cleanupSrvCookiesLocked(now)
}</span>

func (r *Recursive) getSrvCookieLocked(addr netip.Addr) (s string, found bool) <span class="cov4" title="132">{
        c, ok := r.srvcookies[addr]
        if ok &amp;&amp; time.Since(c.ts) &lt; srvCookieTTL </span><span class="cov1" title="3">{
                s = c.value
                found = true
        }</span>
        <span class="cov4" title="132">return</span>
}

func (r *Recursive) setSrvCookie(now time.Time, addr netip.Addr, val string) <span class="cov1" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.srvcookies[addr] = srvCookie{value: val, ts: now}
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package recursive

import (
        "errors"
        "net"
        "strings"
        "syscall"
)

func (r *Recursive) usingUDP() (yes bool) <span class="cov8" title="3">{
        r.mu.RLock()
        yes = r.useUDP
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) usingIPv6() (yes bool) <span class="cov5" title="2">{
        r.mu.RLock()
        yes = r.useIPv6
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) maybeDisableIPv6(err error) (disabled bool) <span class="cov5" title="2">{
        if err != nil </span><span class="cov5" title="2">{
                errstr := err.Error()
                if errors.Is(err, syscall.ENETUNREACH) || errors.Is(err, syscall.EHOSTUNREACH) ||
                        strings.Contains(errstr, "network is unreachable") || strings.Contains(errstr, "no route to host") </span><span class="cov5" title="2">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        if r.useIPv6 </span><span class="cov5" title="2">{
                                r.useIPv6 = false
                                disabled = true
                                var idx int
                                for i := range r.rootServers </span><span class="cov10" title="4">{
                                        if r.rootServers[i].Is4() </span><span class="cov5" title="2">{
                                                r.rootServers[idx] = r.rootServers[i]
                                                idx++
                                        }</span>
                                }
                                <span class="cov5" title="2">r.rootServers = r.rootServers[:idx]</span>
                        }
                }
        }
        <span class="cov5" title="2">return</span>
}

func (r *Recursive) maybeDisableUdp(err error) (disabled bool) <span class="cov8" title="3">{
        var ne net.Error
        if errors.As(err, &amp;ne) &amp;&amp; !ne.Timeout() </span><span class="cov5" title="2">{
                errstr := (err).Error()
                if errors.Is(err, syscall.ENOSYS) || errors.Is(err, syscall.EPROTONOSUPPORT) || strings.Contains(errstr, "network not implemented") </span><span class="cov5" title="2">{
                        r.mu.Lock()
                        disabled = r.useUDP
                        r.useUDP = false
                        r.mu.Unlock()
                }</span>
        }
        <span class="cov8" title="3">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "os"

        "github.com/miekg/dns"
)

// ExtendedRcode represents a DNS Extended Error code as defined in RFC 8914.

type extendedErrorCodeError uint16

func (e extendedErrorCodeError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("extended rcode %v", uint16(e))
}</span>

func (e extendedErrorCodeError) Is(err error) bool <span class="cov2" title="2">{
        return err == ErrExtendedErrorCode
}</span>

var ErrExtendedErrorCode = extendedErrorCodeError(0)

var rcodesToErrors = map[uint16]error{
        dns.ExtendedErrorCodeOther:                io.EOF,
        dns.ExtendedErrorCodeNotReady:             io.ErrNoProgress,
        dns.ExtendedErrorCodeProhibited:           os.ErrPermission,
        dns.ExtendedErrorCodeNoReachableAuthority: os.ErrDeadlineExceeded,
        dns.ExtendedErrorCodeNetworkError:         net.ErrClosed,
        dns.ExtendedErrorCodeInvalidData:          os.ErrInvalid,
}

// ExtendedErrorCodeFromError attempts to map a Go error to a DNS Extended Rcode.
// The function understands well-known errors from the os, io, and net packages
// (including their wrapper types) and returns dns.ExtendedErrorCodeOther if no mapping is known.
func ExtendedErrorCodeFromError(err error) (rcode uint16) <span class="cov7" title="35">{
        rcode = dns.ExtendedErrorCodeOther
        if err != nil </span><span class="cov7" title="34">{
                if rcodeErr, ok := err.(extendedErrorCodeError); ok </span><span class="cov2" title="3">{
                        return uint16(rcodeErr)
                }</span>

                <span class="cov7" title="31">for code, sample := range rcodesToErrors </span><span class="cov10" title="153">{
                        if errors.Is(err, sample) </span><span class="cov5" title="13">{
                                return code
                        }</span>
                }

                <span class="cov6" title="18">if errors.Is(err, os.ErrNotExist) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNoReachableAuthority
                }</span>
                <span class="cov6" title="17">if errors.Is(err, os.ErrExist) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov5" title="16">if errors.Is(err, os.ErrDeadlineExceeded) ||
                        errors.Is(err, context.DeadlineExceeded) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNoReachableAuthority
                }</span>

                <span class="cov5" title="15">if errors.Is(err, io.ErrShortBuffer) || errors.Is(err, io.ErrShortWrite) </span><span class="cov2" title="2">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov5" title="13">if errors.Is(err, io.ErrClosedPipe) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNetworkError
                }</span>
                <span class="cov5" title="12">if errors.Is(err, io.ErrUnexpectedEOF) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>

                <span class="cov5" title="11">var unknownNet net.UnknownNetworkError
                if errors.As(err, &amp;unknownNet) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNetworkError
                }</span>
                <span class="cov5" title="10">var addrErr *net.AddrError
                if errors.As(err, &amp;addrErr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="9">var invalidAddr net.InvalidAddrError
                if errors.As(err, &amp;invalidAddr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="8">var parseErr *net.ParseError
                if errors.As(err, &amp;parseErr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="7">var dnsErr *net.DNSError
                if errors.As(err, &amp;dnsErr) </span><span class="cov3" title="4">{
                        switch </span>{
                        case dnsErr.IsTimeout, dnsErr.IsNotFound:<span class="cov2" title="2">
                                return dns.ExtendedErrorCodeNoReachableAuthority</span>
                        case dnsErr.IsTemporary:<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNotReady</span>
                        default:<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNetworkError</span>
                        }
                }

                <span class="cov2" title="3">var netErr net.Error
                if errors.As(err, &amp;netErr) </span><span class="cov2" title="3">{
                        switch </span>{
                        case netErr.Timeout():<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNoReachableAuthority</span>
                        default:<span class="cov2" title="2">
                                return dns.ExtendedErrorCodeNetworkError</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

// ErrorFromExtendedErrorCode returns the canonical Go error for the provided
// Extended Error Code. It returns ErrExtendedErrorCode if there is no known mapping.
func ErrorFromExtendedErrorCode(code uint16) (err error) <span class="cov4" title="7">{
        var ok bool
        if err, ok = rcodesToErrors[code]; !ok </span><span class="cov1" title="1">{
                err = extendedErrorCodeError(code)
        }</span>
        <span class="cov4" title="7">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package recursive

import (
        "encoding/binary"
        "io"
)

func readInt64(r io.Reader, numread *int64) (val int64, err error) <span class="cov3" title="12">{
        b := [8]byte{}
        var n int
        if n, err = io.ReadFull(r, b[:]); err == nil </span><span class="cov3" title="12">{
                val = int64(binary.BigEndian.Uint64(b[:])) //#nosec
        }</span>
        <span class="cov3" title="12">*numread += int64(n)
        return</span>
}

func writeInt64(w io.Writer, written *int64, val int64) (err error) <span class="cov3" title="15">{
        b := [8]byte{}
        binary.BigEndian.PutUint64(b[:], uint64(val)) //#nosec
        var n int
        n, err = writeAll(w, b[:])
        *written += int64(n)
        return
}</span>

func writeAll(w io.Writer, p []byte) (n int, err error) <span class="cov10" title="39544">{
        for len(p) &gt; 0 &amp;&amp; err == nil </span><span class="cov9" title="39299">{
                var written int
                written, err = w.Write(p)
                n += written
                if err == nil </span><span class="cov9" title="39299">{
                        if written &gt; 0 </span><span class="cov9" title="39298">{
                                p = p[written:]
                        }</span> else<span class="cov1" title="1"> {
                                err = io.ErrShortWrite
                        }</span>
                }
        }
        <span class="cov10" title="39544">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package recursive

import (
        "fmt"

        "github.com/miekg/dns"
)

type MismatchedQuestionError struct {
        ExpectedQName string
        ExpectedQType uint16
        ActualQName   string
        ActualQType   uint16
}

func (e *MismatchedQuestionError) Error() string <span class="cov4" title="2">{
        return fmt.Sprintf(
                "mismatched response question expected=%q/%s actual=%q/%s",
                e.ExpectedQName,
                dns.Type(e.ExpectedQType),
                e.ActualQName,
                dns.Type(e.ActualQType),
        )
}</span>

func (*MismatchedQuestionError) Is(target error) bool <span class="cov10" title="7">{
        _, ok := target.(*MismatchedQuestionError)
        return ok
}</span>

// ErrMismatchedQuestion is returned when a response question does not match the query.
var ErrMismatchedQuestion = &amp;MismatchedQuestionError{}
</pre>
		
		<pre class="file" id="file11" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sort"
        "sync"
        "time"
)

func (r *Recursive) OrderRoots(ctx context.Context) <span class="cov1" title="1">{
        r.OrderRootsTimeout(ctx, time.Second)
}</span>

// OrderRootsTimeout sorts the root server list by their current latency and removes those that don't respond within cutoff.
func (r *Recursive) OrderRootsTimeout(ctx context.Context, cutoff time.Duration) <span class="cov2" title="2">{
        if _, ok := ctx.Deadline(); !ok </span><span class="cov2" title="2">{
                newctx, cancel := context.WithTimeout(ctx, cutoff*2)
                defer cancel()
                ctx = newctx
        }</span>
        <span class="cov2" title="2">r.mu.Lock()
        defer r.mu.Unlock()
        var l []*rootRtt
        var wg sync.WaitGroup
        for _, addr := range r.rootServers </span><span class="cov8" title="52">{
                rt := &amp;rootRtt{addr: addr}
                l = append(l, rt)
                wg.Add(1)
                go timeRoot(ctx, r, &amp;wg, rt)
        }</span>
        <span class="cov2" title="2">wg.Wait()
        sort.Slice(l, func(i, j int) bool </span><span class="cov10" title="158">{ return l[i].rtt &lt; l[j].rtt }</span>)
        <span class="cov2" title="2">var newRootServers []netip.Addr
        useIPv4 := false
        useIPv6 := false
        for _, rt := range l </span><span class="cov8" title="52">{
                if rt.rtt &lt;= cutoff </span><span class="cov6" title="24">{
                        useIPv4 = useIPv4 || rt.addr.Is4()
                        useIPv6 = useIPv6 || rt.addr.Is6()
                        newRootServers = append(newRootServers, rt.addr)
                }</span>
        }
        <span class="cov2" title="2">if len(newRootServers) &gt; 0 </span><span class="cov2" title="2">{
                r.rootServers = newRootServers
                r.useIPv4 = useIPv4
                r.useIPv6 = useIPv6
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package recursive

import (
        "context"
        "fmt"
        "io"
        "math/rand/v2"
        "net"
        "net/netip"
        "slices"
        "sort"
        "strings"
        "time"

        "github.com/miekg/dns"
)

type query struct {
        *Recursive
        cache Cacher
        logw  io.Writer
        start time.Time
        depth int
        steps int
        glue  map[string][]netip.Addr
}

func (q *query) dive(format string, args ...any) (err error) <span class="cov5" title="136">{
        err = ErrMaxSteps
        if q.steps &lt; maxSteps </span><span class="cov5" title="136">{
                err = ErrMaxDepth
                if q.depth &lt; maxDepth </span><span class="cov5" title="136">{
                        q.steps++
                        err = nil
                        if format != "" </span><span class="cov5" title="136">{
                                q.logf(format, args...)
                        }</span>
                        <span class="cov5" title="136">q.depth++</span>
                }
        }
        <span class="cov5" title="136">return</span>
}

func (q *query) surface() <span class="cov5" title="136">{
        q.depth--
}</span>

func (q *query) resolve(ctx context.Context, qname string, qtype uint16) (resp *dns.Msg, srv netip.Addr, err error) <span class="cov5" title="76">{
        var servers []netip.Addr
        qname = dns.CanonicalName(qname)
        if servers, resp, srv, err = q.queryDelegation(ctx, qname); err == nil </span><span class="cov5" title="75">{
                if resp != nil &amp;&amp; resp.Rcode == dns.RcodeNameError </span><span class="cov4" title="39">{
                        // no need to query final
                        if len(resp.Question) == 1 &amp;&amp; (dns.CanonicalName(resp.Question[0].Name) != qname || resp.Question[0].Qtype != qtype) </span><span class="cov4" title="39">{
                                if resp.Zero </span><span class="cov4" title="35">{
                                        resp = resp.Copy()
                                        resp.Zero = false
                                }</span>
                                <span class="cov4" title="39">resp.Question[0].Name = qname
                                resp.Question[0].Qtype = qtype</span>
                        }
                } else<span class="cov4" title="36"> {
                        resp, srv, err = q.queryFinal(ctx, qname, qtype, servers)
                }</span>
        }
        <span class="cov5" title="76">return</span>
}

func (q *query) using() (using []string) <span class="cov1" title="1">{
        if q.logw != nil </span><span class="cov0" title="0">{
                q.mu.RLock()
                if q.useIPv4 </span><span class="cov0" title="0">{
                        using = append(using, "IPv4")
                }</span>
                <span class="cov0" title="0">if q.useIPv6 </span><span class="cov0" title="0">{
                        using = append(using, "IPv6")
                }</span>
                <span class="cov0" title="0">if q.useUDP </span><span class="cov0" title="0">{
                        using = append(using, "UDP")
                }</span>
                <span class="cov0" title="0">q.mu.RUnlock()</span>
        }
        <span class="cov1" title="1">return</span>
}

func (q *query) queryDelegation(ctx context.Context, qname string) (servers []netip.Addr, resp *dns.Msg, srv netip.Addr, err error) <span class="cov5" title="78">{
        if err = q.dive("DELEGATION QUERY %q\n", qname); err == nil </span><span class="cov5" title="78">{
                defer func() </span><span class="cov5" title="78">{
                        q.surface()
                        rcode := "UNKNOWN"
                        if resp != nil </span><span class="cov5" title="77">{
                                rcode = dns.RcodeToString[resp.Rcode]
                        }</span> else<span class="cov1" title="1"> if err != nil </span><span class="cov1" title="1">{
                                rcode = err.Error()
                        }</span>
                        <span class="cov5" title="78">q.logf("DELEGATION ANSWER %q: %s with %d servers\n", qname, rcode, len(servers))</span>
                }()

                <span class="cov5" title="78">q.mu.RLock()
                servers = append([]netip.Addr(nil), q.rootServers...)
                q.mu.RUnlock()
                labels := dns.SplitDomainName(qname)

                // Walk down: "." -&gt; "com." -&gt; "example.com."
                for i := len(labels) - 1; i &gt;= 0; i-- </span><span class="cov6" title="244">{
                        zone := dns.Fqdn(strings.Join(labels[i:], "."))
                        var nsAddrs []netip.Addr

                        if nsAddrs, resp, srv, err = q.queryForDelegation(ctx, zone, servers, qname); err != nil </span><span class="cov1" title="1">{
                                q.logf("DELEGATION ERROR %q: @%s %v (using %v)\n", zone, srv, err, q.using())
                                return
                        }</span>
                        <span class="cov6" title="243">if resp != nil &amp;&amp; resp.Rcode == dns.RcodeNameError </span><span class="cov4" title="39">{
                                if len(resp.Question) == 1 &amp;&amp; dns.CanonicalName(resp.Question[0].Name) == qname </span><span class="cov4" title="39">{
                                        return
                                }</span>
                        }

                        <span class="cov6" title="204">if len(nsAddrs) &gt; 0 </span><span class="cov6" title="153">{
                                // got a new set of servers to query
                                servers = q.sortAddrs(nsAddrs)
                                if i == 0 </span><span class="cov1" title="2">{
                                        // If the final minimized step returned a delegation, probe the delegated NS set once.
                                        // This ensures delegation lookup does not stop before querying the final NS servers.
                                        var probeResp *dns.Msg
                                        var probeSrv netip.Addr
                                        var probeErr error
                                        if _, probeResp, probeSrv, probeErr = q.queryForDelegationWithCachePolicy(ctx, qname, servers, qname, isAuthoritativeCacheResponse); probeErr == nil </span><span class="cov1" title="2">{
                                                if probeResp != nil </span><span class="cov1" title="2">{
                                                        resp = probeResp
                                                        srv = probeSrv
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov4" title="38">return</span>
}

// queryForDelegation performs the QMIN step at `zone` against `parentServers`.
func (q *query) queryForDelegation(ctx context.Context, zone string, parentServers []netip.Addr, fullQname string) (nsAddrs []netip.Addr, resp *dns.Msg, srv netip.Addr, err error) <span class="cov6" title="252">{
        return q.queryForDelegationWithCachePolicy(ctx, zone, parentServers, fullQname, nil)
}</span>

func (q *query) queryForDelegationWithCachePolicy(ctx context.Context, zone string, parentServers []netip.Addr, fullQname string, allowCached func(*dns.Msg) bool) (nsAddrs []netip.Addr, resp *dns.Msg, srv netip.Addr, err error) <span class="cov6" title="254">{
        var nsNames []string
        queryName := zone
        maybeRetryWithoutQMIN := func() (yes bool) </span><span class="cov5" title="130">{
                if yes = queryName != fullQname; yes </span><span class="cov4" title="23">{
                        q.logf("DELEGATION RETRY without QNAME minimization\n")
                        queryName = fullQname
                }</span>
                <span class="cov5" title="130">return</span>
        }
<span class="cov6" title="254">retryWithoutQMIN:
        for _, srv = range parentServers </span><span class="cov7" title="447">{
                if resp, err = q.exchangeWithCachePolicy(ctx, queryName, dns.TypeNS, srv, allowCached); resp != nil &amp;&amp; err == nil </span><span class="cov7" title="447">{
                        if resp.Rcode == dns.RcodeSuccess </span><span class="cov6" title="374">{
                                nsNames, nsAddrs = q.extractDelegationNS(resp, zone)
                                if len(nsNames) &gt; 0 </span><span class="cov6" title="172">{
                                        if len(nsAddrs) == 0 </span><span class="cov3" title="18">{
                                                nsAddrs = q.resolveNSAddrs(ctx, nsNames)
                                        }</span>
                                }
                                <span class="cov6" title="374">if len(nsAddrs) &gt; 0 </span><span class="cov6" title="160">{
                                        return
                                }</span>
                                <span class="cov6" title="214">if resp.Authoritative &amp;&amp; len(nsNames) == 0 </span><span class="cov5" title="57">{
                                        if maybeRetryWithoutQMIN() </span><span class="cov3" title="17">{
                                                goto retryWithoutQMIN</span>
                                        }
                                        <span class="cov4" title="40">return</span>
                                }
                        }
                        <span class="cov6" title="230">if resp.Rcode != dns.RcodeSuccess </span><span class="cov5" title="73">{
                                if maybeRetryWithoutQMIN() </span><span class="cov2" title="6">{
                                        goto retryWithoutQMIN</span>
                                }
                                <span class="cov5" title="67">if resp.Rcode == dns.RcodeNameError &amp;&amp; resp.Authoritative </span><span class="cov4" title="37">{
                                        return
                                }</span>
                        }
                }
        }

        <span class="cov3" title="17">if resp == nil &amp;&amp; err == nil </span><span class="cov1" title="1">{
                err = ErrNoResponse
        }</span>

        <span class="cov3" title="17">return</span>
}

func (q *query) extractDelegationNS(m *dns.Msg, zone string) (nsNames []string, nsAddr []netip.Addr) <span class="cov6" title="374">{
        // extract delegation NS records
        for _, rr := range m.Ns </span><span class="cov8" title="1809">{
                if ns, ok := rr.(*dns.NS); ok </span><span class="cov8" title="1790">{
                        if strings.EqualFold(ns.Hdr.Name, zone) </span><span class="cov8" title="1153">{
                                nsName := dns.CanonicalName(ns.Ns)
                                if !slices.Contains(nsNames, nsName) </span><span class="cov8" title="1153">{
                                        nsNames = append(nsNames, nsName)
                                }</span>
                        }
                }
        }
        // extract glue records
        <span class="cov6" title="374">for _, rr := range m.Extra </span><span class="cov9" title="3509">{
                var addr netip.Addr
                switch a := rr.(type) </span>{
                case *dns.A:<span class="cov8" title="1642">
                        addr = ipToAddr(a.A)</span>
                case *dns.AAAA:<span class="cov8" title="1520">
                        addr = ipToAddr(a.AAAA)</span>
                }
                <span class="cov9" title="3509">if addr.IsValid() </span><span class="cov9" title="3162">{
                        hdrName := dns.CanonicalName(rr.Header().Name)
                        if slices.Contains(nsNames, hdrName) </span><span class="cov8" title="2006">{
                                if !slices.Contains(q.glue[hdrName], addr) </span><span class="cov6" title="317">{
                                        q.glue[hdrName] = append(q.glue[hdrName], addr)
                                }</span>
                        }
                }
        }
        // build list of addresses belonging to nsNames
        <span class="cov6" title="374">addrs := map[netip.Addr]struct{}{}
        for _, nsName := range nsNames </span><span class="cov8" title="1153">{
                for _, addr := range q.glue[nsName] </span><span class="cov8" title="2006">{
                        addrs[addr] = struct{}{}
                }</span>
        }
        <span class="cov6" title="374">for addr := range addrs </span><span class="cov8" title="2006">{
                nsAddr = append(nsAddr, addr)
        }</span>
        <span class="cov6" title="374">return</span>
}

// queryFinal asks the authoritative (or closest) servers for the target qname/qtype.
// It also performs CNAME/DNAME chasing, with a loop bound controlled by depth.
func (q *query) queryFinal(ctx context.Context, qname string, qtype uint16, authServers []netip.Addr) (resp *dns.Msg, svr netip.Addr, err error) <span class="cov4" title="39">{
        if err = q.dive("QUERY %s %q from %d servers\n", dns.Type(qtype), qname, len(authServers)); err == nil </span><span class="cov4" title="39">{
                defer func() </span><span class="cov4" title="39">{
                        q.surface()
                        q.logf("ANSWER @%s %s %q", svr, dns.Type(qtype), qname)
                        q.logResponse(0, resp, err)
                }</span>()
                <span class="cov4" title="39">for _, svr = range authServers </span><span class="cov4" title="41">{
                        if resp, err = q.exchangeWithCachePolicy(ctx, qname, qtype, svr, isAuthoritativeCacheResponse); resp != nil &amp;&amp; err == nil </span><span class="cov4" title="41">{
                                if resp.Rcode == dns.RcodeSuccess </span><span class="cov4" title="40">{
                                        terminal := hasRRType(resp.Answer, qtype)
                                        if !terminal </span><span class="cov3" title="9">{
                                                if tgt := cnameTarget(resp, qname); tgt != "" </span><span class="cov2" title="7">{
                                                        q.logf("CNAME @%s %s %q =&gt; %q\n", svr, dns.Type(qtype), qname, tgt)
                                                        var msg *dns.Msg
                                                        var origin netip.Addr
                                                        msg, origin, err = q.resolve(ctx, tgt, qtype)
                                                        if err == nil </span><span class="cov2" title="7">{
                                                                msg = cloneIfCached(msg)
                                                                prependRecords(msg, resp, qname, cnameChainRecords)
                                                                resp = msg
                                                                svr = origin
                                                                terminal = true
                                                        }</span>
                                                } else<span class="cov1" title="2"> if tgt := dnameSynthesize(resp, qname); tgt != "" </span><span class="cov0" title="0">{
                                                        q.logf("DNAME @%s %s %q =&gt; %q\n", svr, dns.Type(qtype), qname, tgt)
                                                        var msg *dns.Msg
                                                        var origin netip.Addr
                                                        msg, origin, err = q.resolve(ctx, tgt, qtype)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                msg = cloneIfCached(msg)
                                                                prependRecords(msg, resp, qname, dnameRecords)
                                                                resp = msg
                                                                svr = origin
                                                                terminal = true
                                                        }</span>
                                                } else<span class="cov1" title="2"> if qtype == dns.TypeNS </span><span class="cov1" title="1">{
                                                        answers := delegationRecords(resp, qname)
                                                        if len(answers) &gt; 0 </span><span class="cov1" title="1">{
                                                                // returning parent delegation
                                                                resp = resp.Copy()
                                                                resp.Zero = false
                                                                resp.Answer = answers
                                                                resp.Extra = nil
                                                                resp.Ns = nil
                                                                terminal = true
                                                        }</span>
                                                }
                                                <span class="cov3" title="9">if err != nil </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                                <span class="cov3" title="9">if !terminal &amp;&amp; !resp.Authoritative </span><span class="cov1" title="1">{
                                                        resp = nil
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov4" title="39">return</span>
                                }

                                <span class="cov1" title="1">if resp.Rcode == dns.RcodeNameError </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // got an unhandled RCODE, try the next server
                        }
                }

                <span class="cov0" title="0">if resp == nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = ErrNoResponse
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// resolveNSAddrs minimally resolves NS owner names to addresses by asking the roots when glue is missing
func (q *query) resolveNSAddrs(ctx context.Context, nsOwners []string) (addrs []netip.Addr) <span class="cov3" title="19">{
        if q.dive("GLUE QUERY %v\n", nsOwners) == nil </span><span class="cov3" title="19">{
                defer func() </span><span class="cov3" title="19">{
                        q.surface()
                        q.logf("GLUE ANSWER %v\n", addrs)
                }</span>()
                <span class="cov3" title="19">resolved := map[netip.Addr]struct{}{}
                q.mu.RLock()
                useIPv4 := q.useIPv4
                useIPv6 := q.useIPv6
                q.mu.RUnlock()
                for _, host := range nsOwners </span><span class="cov5" title="61">{
                        if useIPv4 </span><span class="cov5" title="60">{
                                if msg, _, err := q.resolve(ctx, host, dns.TypeA); err == nil </span><span class="cov5" title="60">{
                                        for _, rr := range msg.Answer </span><span class="cov4" title="24">{
                                                if a, ok := rr.(*dns.A); ok </span><span class="cov4" title="24">{
                                                        if addr := ipToAddr(a.A); addr.IsValid() </span><span class="cov4" title="24">{
                                                                resolved[addr] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov5" title="61">if useIPv6 </span><span class="cov1" title="1">{
                                if msg, _, err := q.resolve(ctx, host, dns.TypeAAAA); err == nil </span><span class="cov1" title="1">{
                                        for _, rr := range msg.Answer </span><span class="cov1" title="1">{
                                                if a, ok := rr.(*dns.AAAA); ok </span><span class="cov1" title="1">{
                                                        if addr := ipToAddr(a.AAAA); addr.IsValid() </span><span class="cov1" title="1">{
                                                                resolved[addr] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
                <span class="cov3" title="19">for addr := range resolved </span><span class="cov4" title="25">{
                        addrs = append(addrs, addr)
                }</span>
        }
        <span class="cov3" title="19">return</span>
}

func (q *query) logf(format string, args ...any) <span class="cov7" title="767">{
        if q.logw != nil </span><span class="cov7" title="695">{
                _, _ = fmt.Fprintf(q.logw, "[%-5d %2d] %*s", time.Since(q.start).Milliseconds(), q.depth, q.depth, "")
                _, _ = fmt.Fprintf(q.logw, format, args...)
        }</span>
}

func (q *query) logResponse(rtt time.Duration, msg *dns.Msg, err error) <span class="cov7" title="503">{
        if q.logw != nil </span><span class="cov7" title="460">{
                if msg != nil </span><span class="cov7" title="460">{
                        var elapsed string
                        if rtt != 0 </span><span class="cov5" title="105">{
                                elapsed = fmt.Sprintf("%v, ", rtt.Round(time.Millisecond))
                        }</span>
                        <span class="cov7" title="460">_, _ = fmt.Fprintf(q.logw, " =&gt; %s [%v+%v+%v A/N/E] (%s%d bytes",
                                dns.RcodeToString[msg.Rcode],
                                len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                elapsed, msg.Len())
                        if msg.Truncated </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(q.logw, " TRNC")
                        }</span>
                        <span class="cov7" title="460">if msg.Authoritative </span><span class="cov6" title="153">{
                                _, _ = fmt.Fprintf(q.logw, " AUTH")
                        }</span>
                        <span class="cov7" title="460">if opt := msg.IsEdns0(); opt != nil </span><span class="cov7" title="452">{
                                if er := uint16(opt.ExtendedRcode()); /*#nosec G115*/ er != 0 </span><span class="cov0" title="0">{
                                        _, _ = fmt.Fprintf(q.logw, " EDNS=%s", dns.ExtendedErrorCodeToString[er])
                                }</span>
                        }
                        <span class="cov7" title="460">_, _ = fmt.Fprintf(q.logw, ")")</span>
                }
                <span class="cov7" title="460">if err != nil </span><span class="cov0" title="0">{
                        _, _ = fmt.Fprintf(q.logw, " ERROR: %v", err)
                }</span>
                <span class="cov7" title="460">_, _ = fmt.Fprintln(q.logw)</span>
        }
}

func (q *query) exchange(ctx context.Context, qname string, qtype uint16, nsaddr netip.Addr) (resp *dns.Msg, err error) <span class="cov1" title="1">{
        resp, err = q.exchangeWithCachePolicy(ctx, qname, qtype, nsaddr, nil)
        return
}</span>

func (q *query) exchangeWithCachePolicy(ctx context.Context, qname string, qtype uint16, nsaddr netip.Addr, allowCached func(*dns.Msg) bool) (resp *dns.Msg, err error) <span class="cov7" title="489">{
        if q.cache != nil </span><span class="cov7" title="473">{
                if resp = q.cache.DnsGet(qname, qtype); resp != nil </span><span class="cov6" title="362">{
                        if allowCached == nil || allowCached(resp) </span><span class="cov6" title="359">{
                                q.logf("CACHED: %s %q", dns.Type(qtype), qname)
                                q.logResponse(0, resp, nil)
                                return
                        }</span>
                        <span class="cov2" title="3">resp = nil</span>
                }
        }
        <span class="cov5" title="130">q.mu.RLock()
        useUDP := q.useUDP
        useIPv4 := q.useIPv4
        useIPv6 := q.useIPv6
        q.mu.RUnlock()
        if (useIPv4 &amp;&amp; nsaddr.Is4()) || (useIPv6 &amp;&amp; nsaddr.Is6()) </span><span class="cov5" title="130">{
                if useUDP </span><span class="cov5" title="106">{
                        resp, _ = q.exchangeWithNetwork(ctx, "udp", qname, qtype, nsaddr)
                }</span>
                <span class="cov5" title="130">if resp == nil || resp.Truncated </span><span class="cov4" title="25">{
                        resp, err = q.exchangeWithNetwork(ctx, "tcp", qname, qtype, nsaddr)
                }</span>
                <span class="cov5" title="130">if resp != nil &amp;&amp; q.cache != nil &amp;&amp; isReusableCachedResponse(resp) </span><span class="cov5" title="112">{
                        q.cache.DnsSet(resp)
                }</span>
        }
        <span class="cov5" title="130">return</span>
}

func isAuthoritativeCacheResponse(resp *dns.Msg) (ok bool) <span class="cov3" title="9">{
        if resp != nil </span><span class="cov3" title="9">{
                ok = resp.Authoritative
        }</span>
        <span class="cov3" title="9">return</span>
}

func isReusableCachedResponse(resp *dns.Msg) (ok bool) <span class="cov5" title="114">{
        if resp != nil &amp;&amp; !resp.Truncated </span><span class="cov5" title="114">{
                ok = (resp.Rcode == dns.RcodeSuccess) || (resp.Rcode == dns.RcodeNameError &amp;&amp; resp.Authoritative)
        }</span>
        <span class="cov5" title="114">return</span>
}

func (q *query) exchangeWithNetwork(ctx context.Context, protocol string, qname string, qtype uint16, nsaddr netip.Addr) (msg *dns.Msg, err error) <span class="cov5" title="132">{
        if err = q.getCachedNetError(ctx, protocol, nsaddr); err == nil </span><span class="cov5" title="132">{
                var network string
                if nsaddr.Is4() </span><span class="cov5" title="132">{
                        network = protocol + "4"
                }</span> else<span class="cov0" title="0"> {
                        network = protocol + "6"
                }</span>

                <span class="cov5" title="132">if q.rateLimiter != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                err = ctx.Err()
                                return</span>
                        case &lt;-q.rateLimiter:<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov5" title="132">if q.logw != nil </span><span class="cov5" title="105">{
                        var protostr string
                        var dash6str string
                        if protocol != "udp" </span><span class="cov0" title="0">{
                                protostr = " +" + protocol
                        }</span>
                        <span class="cov5" title="105">if nsaddr.Is6() </span><span class="cov0" title="0">{
                                dash6str = " -6"
                        }</span>
                        <span class="cov5" title="105">q.logf("SENDING %s: @%s%s%s %s %q", network, nsaddr, protostr, dash6str, dns.Type(qtype), qname)</span>
                }

                <span class="cov5" title="132">var nconn net.Conn
                var rtt time.Duration

                q.mu.RLock()
                if q.Timeout &gt; 0 </span><span class="cov5" title="132">{
                        ctx2, cancel := context.WithTimeout(ctx, q.Timeout)
                        defer cancel()
                        ctx = ctx2
                }</span>
                <span class="cov5" title="132">clicookie := q.clicookie
                srvcookie, hasSrvCookie := q.getSrvCookieLocked(nsaddr)
                msgsize := q.MsgSize
                q.mu.RUnlock()

                if nconn, err = q.DialContext(ctx, network, netip.AddrPortFrom(nsaddr, q.DNSPort).String()); err == nil </span><span class="cov5" title="132">{
                        dnsconn := &amp;dns.Conn{Conn: nconn, UDPSize: msgsize}
                        defer func() </span><span class="cov5" title="132">{ _ = dnsconn.Close() }</span>()

                        <span class="cov5" title="132">m := new(dns.Msg)
                        m.SetQuestion(qname, qtype)
                        m.RecursionDesired = false
                        opt := new(dns.OPT)
                        opt.Hdr.Name = "."
                        opt.Hdr.Rrtype = dns.TypeOPT
                        opt.SetUDPSize(msgsize)

                        // an existing but empty string for srvcookie means cookies are disabled for this server
                        useCookies := !hasSrvCookie || srvcookie != ""
                        if useCookies </span><span class="cov5" title="132">{
                                opt.Option = append(opt.Option, &amp;dns.EDNS0_COOKIE{
                                        Code:   dns.EDNS0COOKIE,
                                        Cookie: clicookie + srvcookie,
                                })
                                if hasSrvCookie &amp;&amp; q.logw != nil </span><span class="cov2" title="3">{
                                        _, _ = fmt.Fprintf(q.logw, " COOKIE:\"%s|%s\"", maskCookie(clicookie), maskCookie(srvcookie))
                                }</span>
                        }

                        <span class="cov5" title="132">m.Extra = append(m.Extra, opt)
                        c := dns.Client{UDPSize: msgsize}
                        var rawmsg *dns.Msg
                        if rawmsg, rtt, err = c.ExchangeWithConnContext(ctx, m, dnsconn); err == nil </span><span class="cov5" title="132">{
                                if msg, err = validateResponseQuestion(rawmsg, qname, qtype); err == nil </span><span class="cov5" title="131">{
                                        if useCookies </span><span class="cov5" title="131">{
                                                newsrvcookie := srvcookie
                                                if opt := msg.IsEdns0(); opt != nil </span><span class="cov5" title="105">{
                                                        for _, rr := range opt.Option </span><span class="cov2" title="5">{
                                                                switch rr := rr.(type) </span>{
                                                                case *dns.EDNS0_COOKIE:<span class="cov2" title="5">
                                                                        if after, ok := strings.CutPrefix(rr.Cookie, clicookie); ok </span><span class="cov2" title="5">{
                                                                                newsrvcookie = after
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                msg = nil
                                                                                err = ErrInvalidCookie
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                                <span class="cov5" title="131">if err == nil &amp;&amp; newsrvcookie != "" </span><span class="cov2" title="5">{
                                                        if !hasSrvCookie || srvcookie != newsrvcookie </span><span class="cov1" title="2">{
                                                                if q.logw != nil </span><span class="cov1" title="2">{
                                                                        _, _ = fmt.Fprintf(q.logw, " SETCOOKIE:\"%s\"", maskCookie(newsrvcookie))
                                                                }</span>
                                                                <span class="cov1" title="2">q.setSrvCookie(q.start, nsaddr, newsrvcookie)</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }

                <span class="cov5" title="132">isIpv6Err, isUdpErr := q.setNetError(protocol, nsaddr, err)
                ipv6disabled := isIpv6Err &amp;&amp; q.maybeDisableIPv6(err)
                udpDisabled := isUdpErr &amp;&amp; q.maybeDisableUdp(err)

                if q.logw != nil </span><span class="cov5" title="105">{
                        if ipv6disabled </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(q.logw, " (IPv6 disabled)")
                        }</span>
                        <span class="cov5" title="105">if udpDisabled </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(q.logw, " (UDP disabled)")
                        }</span>
                        <span class="cov5" title="105">q.logResponse(rtt, msg, err)</span>
                }

                <span class="cov5" title="132">if !hasSrvCookie &amp;&amp; msg != nil &amp;&amp; msg.Rcode == dns.RcodeFormatError </span><span class="cov0" title="0">{
                        q.logf("got FORMERR, disabling cookies for %v and retrying\n", nsaddr)
                        q.setSrvCookie(q.start, nsaddr, "")
                        return q.exchangeWithNetwork(ctx, protocol, qname, qtype, nsaddr)
                }</span>
        }
        <span class="cov5" title="132">return</span>
}

func (r *Recursive) getCachedNetError(ctx context.Context, protocol string, nsaddr netip.Addr) (err error) <span class="cov5" title="132">{
        if err = ctx.Err(); err == nil </span><span class="cov5" title="132">{
                var m map[netip.Addr]*CachedNetError
                switch protocol </span>{
                case "udp", "udp4", "udp6":<span class="cov5" title="106">
                        m = r.udperrs</span>
                case "tcp", "tcp4", "tcp6":<span class="cov4" title="26">
                        m = r.tcperrs</span>
                }
                <span class="cov5" title="132">if m != nil </span><span class="cov5" title="132">{
                        r.mu.RLock()
                        ne := m[nsaddr]
                        r.mu.RUnlock()
                        if ne != nil </span><span class="cov0" title="0">{
                                if time.Since(ne.When) &lt; time.Minute </span><span class="cov0" title="0">{
                                        err = ne
                                }</span> else<span class="cov0" title="0"> {
                                        r.mu.Lock()
                                        delete(m, nsaddr)
                                        r.mu.Unlock()
                                }</span>
                        }
                }
        }
        <span class="cov5" title="132">return</span>
}

func (r *Recursive) sortAddrs(in []netip.Addr) []netip.Addr <span class="cov6" title="153">{
        if r.Deterministic </span><span class="cov6" title="149">{
                sort.Slice(in, func(i, j int) bool </span><span class="cov10" title="7674">{ return in[i].Compare(in[j]) &lt; 0 }</span>)
        } else<span class="cov2" title="4"> {
                rand.Shuffle(len(in), func(i, j int) </span><span class="cov0" title="0">{ in[i], in[j] = in[j], in[i] }</span>)
        }
        <span class="cov6" title="153">return in</span>
}

func cnameTarget(resp *dns.Msg, owner string) (tgt string) <span class="cov3" title="9">{
        for _, rr := range resp.Answer </span><span class="cov2" title="7">{
                if c, ok := rr.(*dns.CNAME); ok &amp;&amp; strings.EqualFold(c.Hdr.Name, owner) </span><span class="cov2" title="7">{
                        tgt = dns.CanonicalName(c.Target)
                }</span>
        }
        <span class="cov3" title="9">return</span>
}

// dnameSynthesize finds a DNAME and synthesizes the new qname per RFC 6672.
func dnameSynthesize(resp *dns.Msg, qname string) (tgt string) <span class="cov2" title="5">{
        for _, rr := range resp.Answer </span><span class="cov2" title="3">{
                if d, ok := rr.(*dns.DNAME); ok </span><span class="cov2" title="3">{
                        if before, ok0 := cutDomainSuffix(qname, d.Hdr.Name); ok0 </span><span class="cov1" title="2">{
                                prefix := before
                                // Avoid double dots when concatenating
                                prefix = strings.TrimSuffix(prefix, ".")
                                candidate := d.Target
                                if prefix != "" </span><span class="cov1" title="1">{
                                        candidate = strings.Trim(prefix, ".") + "." + d.Target
                                }</span>
                                <span class="cov1" title="2">tgt = dns.CanonicalName(candidate)
                                break</span>
                        }
                }
        }
        <span class="cov2" title="5">return</span>
}

func hasRRType(rrs []dns.RR, t uint16) bool <span class="cov4" title="40">{
        for _, rr := range rrs </span><span class="cov4" title="38">{
                if rr.Header().Rrtype == t </span><span class="cov4" title="31">{
                        return true
                }</span>
        }
        <span class="cov3" title="9">return false</span>
}

func delegationRecords(m *dns.Msg, zone string) (out []dns.RR) <span class="cov1" title="1">{
        if m != nil </span><span class="cov1" title="1">{
                for _, rr := range m.Ns </span><span class="cov2" title="3">{
                        if ns, ok := rr.(*dns.NS); ok </span><span class="cov2" title="3">{
                                if strings.EqualFold(ns.Hdr.Name, zone) </span><span class="cov2" title="3">{
                                        out = append(out, rr)
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}
func cnameChainRecords(rrs []dns.RR, owner string) []dns.RR <span class="cov3" title="9">{
        var out []dns.RR
        for _, rr := range rrs </span><span class="cov3" title="9">{
                if cname, ok := rr.(*dns.CNAME); ok </span><span class="cov3" title="9">{
                        if strings.EqualFold(cname.Hdr.Name, owner) </span><span class="cov3" title="9">{
                                out = append(out, rr)
                        }</span>
                }
        }
        <span class="cov3" title="9">return out</span>
}

func dnameRecords(rrs []dns.RR, qname string) []dns.RR <span class="cov1" title="2">{
        var out []dns.RR
        for _, rr := range rrs </span><span class="cov2" title="4">{
                if d, ok := rr.(*dns.DNAME); ok </span><span class="cov1" title="2">{
                        if _, match := cutDomainSuffix(qname, d.Hdr.Name); match </span><span class="cov1" title="1">{
                                out = append(out, rr)
                        }</span>
                }
                <span class="cov2" title="4">if cname, ok := rr.(*dns.CNAME); ok </span><span class="cov1" title="1">{
                        if strings.EqualFold(cname.Hdr.Name, qname) </span><span class="cov1" title="1">{
                                out = append(out, rr)
                        }</span>
                }
        }
        <span class="cov1" title="2">return out</span>
}

func cutDomainSuffix(name, suffix string) (before string, ok bool) <span class="cov2" title="5">{
        name = strings.ToLower(dns.CanonicalName(name))
        suffix = strings.ToLower(dns.CanonicalName(suffix))
        if before, ok = strings.CutSuffix(name, suffix); ok </span><span class="cov2" title="5">{
                ok = before == "" || strings.HasSuffix(before, ".")
        }</span>
        <span class="cov2" title="5">return</span>
}

func prependRecords(msg *dns.Msg, resp *dns.Msg, qname string, gather func([]dns.RR, string) []dns.RR) <span class="cov3" title="9">{
        records := gather(resp.Answer, qname)
        if len(msg.Question) &gt; 0 </span><span class="cov3" title="9">{
                msg.Question[0].Name = qname
        }</span>
        <span class="cov3" title="9">if len(records) &gt; 0 </span><span class="cov3" title="9">{
                msg.Answer = append(append([]dns.RR(nil), records...), msg.Answer...)
        }</span>
        <span class="cov3" title="9">if len(msg.Ns) == 0 </span><span class="cov1" title="1">{
                if len(resp.Ns) &gt; 0 </span><span class="cov0" title="0">{
                        msg.Ns = append([]dns.RR(nil), resp.Ns...)
                }</span>
        }
        <span class="cov3" title="9">if len(resp.Extra) &gt; 0 </span><span class="cov3" title="8">{
                var extras []dns.RR
                for _, rr := range resp.Extra </span><span class="cov3" title="10">{
                        if rr.Header().Rrtype != dns.TypeOPT </span><span class="cov1" title="2">{
                                extras = append(extras, rr)
                        }</span>
                }
                <span class="cov3" title="8">if len(extras) &gt; 0 </span><span class="cov1" title="1">{
                        msg.Extra = append(extras, msg.Extra...)
                }</span>
        }
}

func ipToAddr(ip net.IP) (addr netip.Addr) <span class="cov9" title="3188">{
        if ip != nil </span><span class="cov9" title="3188">{
                if v4 := ip.To4(); v4 != nil </span><span class="cov8" title="1667">{
                        addr = netip.AddrFrom4([4]byte(v4))
                }</span> else<span class="cov8" title="1521"> if v6 := ip.To16(); v6 != nil </span><span class="cov8" title="1521">{
                        addr = netip.AddrFrom16([16]byte(v6))
                }</span>
        }
        <span class="cov9" title="3188">return</span>
}

func cloneIfCached(msg *dns.Msg) (clone *dns.Msg) <span class="cov3" title="9">{
        clone = msg
        if msg.Zero </span><span class="cov1" title="1">{
                clone = msg.Copy()
                clone.Zero = false
        }</span>
        <span class="cov3" title="9">return</span>
}

func validateResponseQuestion(msg *dns.Msg, qname string, qtype uint16) (outmsg *dns.Msg, err error) <span class="cov5" title="132">{
        mismatchedQuestionErr := &amp;MismatchedQuestionError{
                ExpectedQName: dns.CanonicalName(qname),
                ExpectedQType: qtype,
        }
        err = mismatchedQuestionErr
        if msg != nil </span><span class="cov5" title="132">{
                if len(msg.Question) &gt; 0 </span><span class="cov5" title="132">{
                        q := msg.Question[0]
                        mismatchedQuestionErr.ActualQName = dns.CanonicalName(q.Name)
                        mismatchedQuestionErr.ActualQType = q.Qtype
                        if len(msg.Question) == 1 </span><span class="cov5" title="132">{
                                if mismatchedQuestionErr.ActualQName == mismatchedQuestionErr.ExpectedQName </span><span class="cov5" title="131">{
                                        if mismatchedQuestionErr.ActualQType == mismatchedQuestionErr.ExpectedQType &amp;&amp; q.Qclass == dns.ClassINET </span><span class="cov5" title="131">{
                                                err = nil
                                                outmsg = msg
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov5" title="132">return</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// package recursive provides a minimal iterative DNS resolver with QNAME minimization
// using github.com/miekg/dns for wire format and transport.
package recursive

import (
        "context"
        "errors"
        "io"
        "net"
        "net/netip"
        "os"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/miekg/dns"
        "golang.org/x/net/proxy"
)

//go:generate go run ./cmd/genhints roothints.gen.go

const (
        maxSrvCookies = 8192
        srvCookieTTL  = 24 * time.Hour
        maxDepth      = 16   // max recursion depth
        maxSteps      = 4096 // max steps to take for a query
)

type Recursive struct {
        proxy.ContextDialer                 // context dialer to use
        Cacher                              // cache to use for DnsResolve
        Timeout             time.Duration   // default is DefaultTimeout
        DNSPort             uint16          // default is DefaultDNSPort
        Deterministic       bool            // if true, always query nameservers in the same order
        MsgSize             uint16          // UDP message size
        rateLimiter         &lt;-chan struct{} // (read-only) rate limited passed to NewWithOptions
        mu                  sync.RWMutex    // protects following
        useIPv4             bool
        useIPv6             bool
        useUDP              bool
        rootServers         []netip.Addr
        clicookie           string
        srvcookies          map[netip.Addr]srvCookie
        udperrs             map[netip.Addr]*CachedNetError
        tcperrs             map[netip.Addr]*CachedNetError
}

func (r *Recursive) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov1" title="1">{
        return r.ResolveWithOptions(ctx, r.Cacher, nil, qname, qtype)
}</span>

var _ Resolver = &amp;Recursive{}

var (
        // ErrInvalidCookie is returned if the DNS cookie from the server is invalid.
        ErrInvalidCookie = errors.New("invalid cookie")
        // ErrMaxDepth is returned when recursive resolving exceeds the allowed limit.
        ErrMaxDepth = errors.New("recursion depth exceeded 16")
        // ErrMaxSteps is returned when resolving exceeds the step limit.
        ErrMaxSteps = errors.New("resolve steps exceeded 4096")
        // ErrNoResponse is returned when no authoritative server could be successfully queried.
        // It is equivalent to SERVFAIL.
        ErrNoResponse = errors.New("no authoritative response")

        DefaultCache          = NewCache()
        DefaultTimeout        = time.Second * 3
        DefaultDNSPort uint16 = 53
        DefaultMsgSize uint16 = 1232 // default UDP message size
)

// NewWithOptions returns a new Recursive resolver using the given ContextDialer and
// using the given Cacher as the cache when calling DnsResolve. It does not call OrderRoots.
//
// Passing nil for dialer will use a net.Dialer.
// Passing nil for the roots will use the default set of roots.
// Passing nil for the rateLimiter means no rate limiting
func NewWithOptions(dialer proxy.ContextDialer, cache Cacher, roots4, roots6 []netip.Addr, rateLimiter &lt;-chan struct{}) *Recursive <span class="cov6" title="19">{
        if dialer == nil </span><span class="cov4" title="7">{
                dialer = &amp;net.Dialer{}
        }</span>
        <span class="cov6" title="19">if roots4 == nil </span><span class="cov3" title="3">{
                roots4 = Roots4
        }</span>
        <span class="cov6" title="19">if roots6 == nil </span><span class="cov6" title="18">{
                roots6 = Roots6
        }</span>

        <span class="cov6" title="19">var roots []netip.Addr
        roots = append(roots, roots4...)
        roots = append(roots, roots6...)

        return &amp;Recursive{
                ContextDialer: dialer,
                Cacher:        cache,
                DNSPort:       DefaultDNSPort,
                Timeout:       DefaultTimeout,
                MsgSize:       DefaultMsgSize,
                rateLimiter:   rateLimiter,
                useUDP:        true,
                useIPv4:       len(roots4) &gt; 0,
                useIPv6:       len(roots6) &gt; 0,
                rootServers:   roots,
                clicookie:     makeCookie(),
                srvcookies:    make(map[netip.Addr]srvCookie),
                udperrs:       make(map[netip.Addr]*CachedNetError),
                tcperrs:       make(map[netip.Addr]*CachedNetError),
        }</span>
}

// New returns a new Recursive resolver using the given ContextDialer and
// has DefaultCache as it's cache.
//
// It calls OrderRoots before returning.
func New(dialer proxy.ContextDialer) *Recursive <span class="cov1" title="1">{
        r := NewWithOptions(dialer, DefaultCache, nil, nil, nil)
        r.OrderRoots(context.Background())
        return r
}</span>

// ResolveWithOptions performs iterative resolution with QNAME minimization for qname/qtype.
func (r *Recursive) ResolveWithOptions(ctx context.Context, cache Cacher, logw io.Writer, qname string, qtype uint16) (msg *dns.Msg, origin netip.Addr, err error) <span class="cov4" title="7">{
        now := time.Now()
        r.cleanupSrvCookies(now)
        qry := query{
                Recursive: r,
                cache:     cache,
                logw:      logw,
                start:     now,
                glue:      make(map[string][]netip.Addr),
        }
        msg, origin, err = qry.resolve(ctx, qname, qtype)
        return
}</span>

// GetRoots returns the current set of root servers in use.
func (r *Recursive) GetRoots() (root4, root6 []netip.Addr) <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov2" title="2">{
                if addr.Is4() </span><span class="cov1" title="1">{
                        root4 = append(root4, addr)
                }</span>
                <span class="cov2" title="2">if addr.Is6() </span><span class="cov1" title="1">{
                        root6 = append(root6, addr)
                }</span>
        }
        <span class="cov1" title="1">return</span>
}

func (r *Recursive) setNetError(protocol string, nsaddr netip.Addr, err error) (isIpv6err, isUdpErr bool) <span class="cov10" title="135">{
        if err != nil </span><span class="cov3" title="4">{
                isIpv6err = nsaddr.Is6()
                var ne net.Error
                ok := errors.Is(err, io.EOF)
                if errors.As(err, &amp;ne) </span><span class="cov1" title="1">{
                        ok = true
                }</span>
                <span class="cov3" title="4">ok = ok || errors.Is(err, os.ErrDeadlineExceeded) || errors.Is(err, context.DeadlineExceeded)
                ok = ok || errors.Is(err, syscall.ECONNREFUSED) || errors.Is(err, net.ErrClosed)
                errstr := err.Error()
                ok = ok || strings.Contains(errstr, "timeout") || strings.Contains(errstr, "refused")
                if ok </span><span class="cov3" title="3">{
                        var m map[netip.Addr]*CachedNetError
                        switch protocol </span>{
                        case "udp":<span class="cov2" title="2">
                                isUdpErr = true
                                m = r.udperrs</span>
                        case "tcp":<span class="cov1" title="1">
                                m = r.tcperrs</span>
                        }
                        <span class="cov3" title="3">if m != nil </span><span class="cov3" title="3">{
                                r.mu.Lock()
                                m[nsaddr] = &amp;CachedNetError{Err: err, When: time.Now(), Protocol: protocol, Address: nsaddr}
                                r.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov10" title="135">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sync"
        "time"
)

type rootRtt struct {
        addr netip.Addr
        rtt  time.Duration
}

func timeRoot(ctx context.Context, r *Recursive, wg *sync.WaitGroup, rt *rootRtt) <span class="cov8" title="52">{
        defer wg.Done()
        const numProbes = 3
        network := "tcp4"
        if rt.addr.Is6() </span><span class="cov7" title="26">{
                network = "tcp6"
        }</span>
        <span class="cov8" title="52">rt.rtt = time.Hour
        var rtt time.Duration
        for range numProbes </span><span class="cov10" title="102">{
                now := time.Now()
                conn, err := r.DialContext(ctx, network, netip.AddrPortFrom(rt.addr, 53).String())
                if err != nil </span><span class="cov7" title="28">{
                        return
                }</span>
                <span class="cov9" title="74">rtt += time.Since(now)
                _ = conn.Close()</span>
        }
        <span class="cov7" title="24">rt.rtt = rtt / numProbes</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
