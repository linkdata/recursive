
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>recursive: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/recursive/cache.go (0.0%)</option>
				
				<option value="file1">github.com/linkdata/recursive/cacheqtype.go (0.0%)</option>
				
				<option value="file2">github.com/linkdata/recursive/cmd/cli/main.go (0.0%)</option>
				
				<option value="file3">github.com/linkdata/recursive/cmd/genhints/main.go (0.0%)</option>
				
				<option value="file4">github.com/linkdata/recursive/neterror.go (0.0%)</option>
				
				<option value="file5">github.com/linkdata/recursive/netresolver.go (0.0%)</option>
				
				<option value="file6">github.com/linkdata/recursive/query.go (0.0%)</option>
				
				<option value="file7">github.com/linkdata/recursive/recursive.go (0.0%)</option>
				
				<option value="file8">github.com/linkdata/recursive/timeroot.go (0.0%)</option>
				
				<option value="file9">github.com/linkdata/recursive/util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package recursive

import (
        "context"
        "math"
        "net/netip"
        "sync/atomic"
        "time"

        "github.com/miekg/dns"
)

const DefaultMinTTL = 10       // ten seconds
const DefaultMaxTTL = 3600 * 6 // six hours
const DefaultNXTTL = 3600      // one hour
const MaxQtype = 260

var _ Cacher = (*Cache)(nil)
var _ Resolver = (*Cache)(nil)

type Cache struct {
        MinTTL int    // always cache responses for at least this long
        MaxTTL int    // never cache responses for longer than this (excepting successful NS responses)
        NXTTL  int    // cache NXDOMAIN responses for this long
        count  uint64 // atomic
        hits   uint64 // atomic
        cq     []*cacheQtype
}

func NewCache() *Cache <span class="cov0" title="0">{
        cq := make([]*cacheQtype, MaxQtype+1)
        for i := range cq </span><span class="cov0" title="0">{
                cq[i] = newCacheQtype()
        }</span>
        <span class="cov0" title="0">return &amp;Cache{
                MinTTL: DefaultMinTTL,
                MaxTTL: DefaultMaxTTL,
                NXTTL:  DefaultNXTTL,
                cq:     cq,
        }</span>
}

// HitRatio returns the hit ratio as a percentage.
func (cache *Cache) HitRatio() float64 <span class="cov0" title="0">{
        if cache != nil </span><span class="cov0" title="0">{
                if count := atomic.LoadUint64(&amp;cache.count); count &gt; 0 </span><span class="cov0" title="0">{
                        hits := atomic.LoadUint64(&amp;cache.hits)
                        return float64(hits*100) / float64(count)
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// Entries returns the number of entries in the cache.
func (cache *Cache) Entries() (n int) <span class="cov0" title="0">{
        if cache != nil </span><span class="cov0" title="0">{
                for _, cq := range cache.cq </span><span class="cov0" title="0">{
                        n += cq.entries()
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (cache *Cache) DnsSet(msg *dns.Msg) <span class="cov0" title="0">{
        if cache != nil &amp;&amp; msg != nil &amp;&amp; !msg.Zero &amp;&amp; len(msg.Question) == 1 </span><span class="cov0" title="0">{
                if qtype := msg.Question[0].Qtype; qtype &lt;= MaxQtype </span><span class="cov0" title="0">{
                        msg = msg.Copy()
                        msg.Zero = true
                        var ttl int
                        if msg.Rcode == dns.RcodeNameError </span><span class="cov0" title="0">{
                                ttl = cache.NXTTL
                        }</span> else<span class="cov0" title="0"> {
                                ttl = max(cache.MinTTL, MinTTL(msg))
                                if qtype != dns.TypeNS || msg.Rcode != dns.RcodeSuccess </span><span class="cov0" title="0">{
                                        ttl = min(cache.MaxTTL, ttl)
                                }</span>
                        }
                        <span class="cov0" title="0">cache.cq[qtype].set(msg, ttl)</span>
                }
        }
}

func (cache *Cache) DnsGet(qname string, qtype uint16) (msg *dns.Msg) <span class="cov0" title="0">{
        if cache != nil </span><span class="cov0" title="0">{
                atomic.AddUint64(&amp;cache.count, 1)
                if qtype &lt;= MaxQtype </span><span class="cov0" title="0">{
                        if msg = cache.cq[qtype].get(qname); msg != nil </span><span class="cov0" title="0">{
                                atomic.AddUint64(&amp;cache.hits, 1)
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (cache *Cache) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov0" title="0">{
        msg = cache.DnsGet(qname, qtype)
        return
}</span>

func (cache *Cache) Clear() <span class="cov0" title="0">{
        if cache != nil </span><span class="cov0" title="0">{
                for _, cq := range cache.cq </span><span class="cov0" title="0">{
                        cq.clear()
                }</span>
        }
}

func (cache *Cache) Clean() <span class="cov0" title="0">{
        if cache != nil </span><span class="cov0" title="0">{
                now := time.Now()
                for _, cq := range cache.cq </span><span class="cov0" title="0">{
                        cq.clean(now)
                }</span>
        }
}

// MinTTL returns the lowest resource record TTL in the message, or -1 if there are no records.
func MinTTL(msg *dns.Msg) int <span class="cov0" title="0">{
        minTTL := math.MaxInt
        for _, rr := range msg.Answer </span><span class="cov0" title="0">{
                minTTL = min(minTTL, int(rr.Header().Ttl))
        }</span>
        <span class="cov0" title="0">for _, rr := range msg.Ns </span><span class="cov0" title="0">{
                minTTL = min(minTTL, int(rr.Header().Ttl))
        }</span>
        <span class="cov0" title="0">for _, rr := range msg.Extra </span><span class="cov0" title="0">{
                if rr.Header().Rrtype != dns.TypeOPT </span><span class="cov0" title="0">{
                        minTTL = min(minTTL, int(rr.Header().Ttl))
                }</span>
        }
        <span class="cov0" title="0">if minTTL == math.MaxInt </span><span class="cov0" title="0">{
                minTTL = -1
        }</span>
        <span class="cov0" title="0">return minTTL</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package recursive

import (
        "sync"
        "time"

        "github.com/miekg/dns"
)

type cacheQtype struct {
        mu    sync.RWMutex
        cache map[string]cacheValue
}

func newCacheQtype() *cacheQtype <span class="cov0" title="0">{
        return &amp;cacheQtype{cache: make(map[string]cacheValue)}
}</span>

func (cq *cacheQtype) entries() (n int) <span class="cov0" title="0">{
        cq.mu.RLock()
        n = len(cq.cache)
        cq.mu.RUnlock()
        return
}</span>

func (cq *cacheQtype) set(msg *dns.Msg, ttl int) <span class="cov0" title="0">{
        qname := msg.Question[0].Name
        expires := time.Now().Add(time.Duration(ttl) * time.Second)
        cq.mu.Lock()
        cq.cache[qname] = cacheValue{Msg: msg, expires: expires}
        cq.mu.Unlock()
}</span>

func (cq *cacheQtype) get(qname string) *dns.Msg <span class="cov0" title="0">{
        cq.mu.RLock()
        cv := cq.cache[qname]
        cq.mu.RUnlock()
        if cv.Msg != nil </span><span class="cov0" title="0">{
                if time.Since(cv.expires) &lt; 0 </span><span class="cov0" title="0">{
                        return cv.Msg
                }</span>
                <span class="cov0" title="0">cq.mu.Lock()
                delete(cq.cache, qname)
                cq.mu.Unlock()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (cq *cacheQtype) clear() <span class="cov0" title="0">{
        cq.clean(time.Time{})
}</span>

func (cq *cacheQtype) clean(now time.Time) <span class="cov0" title="0">{
        cq.mu.Lock()
        defer cq.mu.Unlock()
        for qname, cv := range cq.cache </span><span class="cov0" title="0">{
                if now.IsZero() || now.After(cv.expires) </span><span class="cov0" title="0">{
                        delete(cq.cache, qname)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "io"
        "log"
        "net/netip"
        "os"
        "runtime"
        "runtime/pprof"
        "strings"
        "time"

        "github.com/linkdata/rate"
        "github.com/linkdata/recursive"
        "github.com/miekg/dns"
)

var flagCpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")
var flagMemprofile = flag.String("memprofile", "", "write memory profile to `file`")
var flagTimeout = flag.Int("timeout", 60, "individual query timeout in seconds")
var flagNomini = flag.Bool("nomini", false, "disable QNAME minimization")
var flagMaxwait = flag.Int("maxwait", 60*1000, "max time to wait for result in milliseconds")
var flagRatelimit = flag.Int("ratelimit", 0, "rate limit queries, 0 means no limit")
var flagCount = flag.Int("count", 1, "repeat count")
var flagSleep = flag.Int("sleep", 0, "sleep ms between repeats")
var flag4 = flag.Bool("4", true, "use IPv4")
var flag6 = flag.Bool("6", false, "use IPv6")
var debug = flag.Bool("debug", false, "print debug output")

func main() <span class="cov0" title="0">{
        flag.Parse()
        if *flagCpuprofile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(*flagCpuprofile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">defer f.Close()
                _ = pprof.StartCPUProfile(f)
                defer pprof.StopCPUProfile()</span>
        }

        <span class="cov0" title="0">qtype := dns.TypeA
        qnames := []string{}
        for _, arg := range flag.Args() </span><span class="cov0" title="0">{
                if x, ok := dns.StringToType[strings.ToUpper(arg)]; ok </span><span class="cov0" title="0">{
                        qtype = x
                }</span> else<span class="cov0" title="0"> {
                        qnames = append(qnames, arg)
                }</span>
        }

        <span class="cov0" title="0">if len(qnames) == 0 </span><span class="cov0" title="0">{
                fmt.Println("missing one or more names to query")
                return
        }</span>

        <span class="cov0" title="0">var roots4, roots6 []netip.Addr
        if *flag4 </span><span class="cov0" title="0">{
                roots4 = recursive.Roots4
        }</span>
        <span class="cov0" title="0">if *flag6 </span><span class="cov0" title="0">{
                roots6 = recursive.Roots6
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), time.Second*time.Duration(*flagTimeout))
        defer cancel()

        maxrate := int32(*flagRatelimit) // #nosec G115
        var rateLimiter &lt;-chan struct{}
        if maxrate &gt; 0 </span><span class="cov0" title="0">{
                rateLimiter = rate.NewTicker(nil, &amp;maxrate).C
        }</span>

        <span class="cov0" title="0">rec := recursive.NewWithOptions(nil, recursive.DefaultCache, roots4, roots6, rateLimiter)
        rec.OrderRoots(ctx)

        var dbgout io.Writer
        if *debug </span><span class="cov0" title="0">{
                dbgout = os.Stderr
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; *flagCount; i++ </span><span class="cov0" title="0">{
                if i &gt; 0 &amp;&amp; *flagSleep &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * time.Duration(*flagSleep))
                }</span>
                <span class="cov0" title="0">for _, qname := range qnames </span><span class="cov0" title="0">{

                        ctx, cancel := context.WithTimeout(ctx, time.Millisecond*time.Duration(*flagMaxwait))
                        if retv, _, err := rec.ResolveWithOptions(ctx, recursive.DefaultCache, dbgout, qname, qtype); err == nil </span><span class="cov0" title="0">{
                                if !*debug </span><span class="cov0" title="0">{
                                        fmt.Println(retv)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("%s %s: %v\n", recursive.DnsTypeToString(qtype), qname, err)
                        }</span>
                        <span class="cov0" title="0">cancel()</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("cache size %d, hit ratio %.2f%%\n", recursive.DefaultCache.Entries(), recursive.DefaultCache.HitRatio())

        if *flagMemprofile != "" </span><span class="cov0" title="0">{
                f, err := os.Create(*flagMemprofile)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
                <span class="cov0" title="0">defer f.Close()
                runtime.GC() // get up-to-date statistics
                if err := pprof.WriteHeapProfile(f); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("could not write memory profile: ", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bytes"
        _ "embed"
        "fmt"
        "io"
        "net/http"
        "net/netip"
        "os"
        "sort"
        "text/template"

        "github.com/miekg/dns"
)

//go:embed roothints.go.tmpl
var roothintsgotmpl string

type Roots struct {
        Roots4 []netip.Addr
        Roots6 []netip.Addr
}

func main() <span class="cov0" title="0">{
        resp, err := http.Get("https://www.internic.net/domain/named.root")
        if err == nil </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                var body []byte
                if body, err = io.ReadAll(resp.Body); err == nil </span><span class="cov0" title="0">{
                        var root4, root6 []netip.Addr
                        zp := dns.NewZoneParser(bytes.NewReader(body), "", "")
                        for rr, ok := zp.Next(); ok; rr, ok = zp.Next() </span><span class="cov0" title="0">{
                                switch rr := rr.(type) </span>{
                                case *dns.A:<span class="cov0" title="0">
                                        if ip, ok := netip.AddrFromSlice(rr.A); ok </span><span class="cov0" title="0">{
                                                if ip = ip.Unmap(); ip.Is4() </span><span class="cov0" title="0">{
                                                        root4 = append(root4, ip)
                                                        ip.AsSlice()
                                                        if !netip.AddrFrom4(ip.As4()).Is4() </span><span class="cov0" title="0">{
                                                                panic("not 4")</span>
                                                        }
                                                }
                                        }
                                case *dns.AAAA:<span class="cov0" title="0">
                                        if ip, ok := netip.AddrFromSlice(rr.AAAA); ok </span><span class="cov0" title="0">{
                                                root6 = append(root6, ip)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">sort.Slice(root4, func(i, j int) bool </span><span class="cov0" title="0">{ return root4[i].Less(root4[j]) }</span>)
                        <span class="cov0" title="0">sort.Slice(root6, func(i, j int) bool </span><span class="cov0" title="0">{ return root6[i].Less(root6[j]) }</span>)

                        <span class="cov0" title="0">if err = zp.Err(); err == nil </span><span class="cov0" title="0">{
                                var of *os.File
                                if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                                        of = os.Stdout
                                }</span> else<span class="cov0" title="0"> {
                                        if of, err = os.Create(os.Args[1]); err == nil </span><span class="cov0" title="0">{
                                                defer of.Close()
                                        }</span>
                                }
                                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                        var t *template.Template
                                        if t, err = template.New("").Parse(roothintsgotmpl); err == nil </span><span class="cov0" title="0">{
                                                err = t.Execute(of, Roots{Roots4: root4, Roots6: root6})
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package recursive

import "time"

type netError struct {
        Err  error
        When time.Time
}

func (ne netError) Error() string <span class="cov0" title="0">{
        return ne.Err.Error()
}</span>

func (ne netError) Unwrap() error <span class="cov0" title="0">{
        return ne.Err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package recursive

import (
        "context"
        "net"
        "net/netip"

        "github.com/miekg/dns"
)

// override some of the standard Go net.Resolver functions

func (rc *Recursive) lookupNetIP(ctx context.Context, ips []net.IP, host string, qtype uint16) ([]net.IP, error) <span class="cov0" title="0">{
        msg, _, err := rc.DnsResolve(ctx, host, qtype)
        if msg != nil </span><span class="cov0" title="0">{
                for _, rr := range msg.Answer </span><span class="cov0" title="0">{
                        switch rr := rr.(type) </span>{
                        case *dns.A:<span class="cov0" title="0">
                                ips = append(ips, rr.A)</span>
                        case *dns.AAAA:<span class="cov0" title="0">
                                ips = append(ips, rr.AAAA)</span>
                        }
                }
        }
        <span class="cov0" title="0">return ips, err</span>
}

func (rc *Recursive) LookupIP(ctx context.Context, network, host string) (ips []net.IP, err error) <span class="cov0" title="0">{
        if network == "ip" || network == "ip4" </span><span class="cov0" title="0">{
                ips, err = rc.lookupNetIP(ctx, ips, host, dns.TypeA)
        }</span>
        <span class="cov0" title="0">if network == "ip" || network == "ip6" </span><span class="cov0" title="0">{
                ips, err = rc.lookupNetIP(ctx, ips, host, dns.TypeAAAA)
        }</span>
        <span class="cov0" title="0">if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (rc *Recursive) LookupHost(ctx context.Context, host string) (addrs []string, err error) <span class="cov0" title="0">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov0" title="0">{
                for _, ip := range ips </span><span class="cov0" title="0">{
                        addrs = append(addrs, ip.String())
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (rc *Recursive) LookupNetIP(ctx context.Context, network, host string) (addrs []netip.Addr, err error) <span class="cov0" title="0">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov0" title="0">{
                for _, ip := range ips </span><span class="cov0" title="0">{
                        if ip, ok := netip.AddrFromSlice(ip); ok </span><span class="cov0" title="0">{
                                addrs = append(addrs, ip)
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (rc *Recursive) LookupIPAddr(ctx context.Context, host string) (addrs []net.IPAddr, err error) <span class="cov0" title="0">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov0" title="0">{
                for _, ip := range ips </span><span class="cov0" title="0">{
                        addrs = append(addrs, net.IPAddr{IP: ip})
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (rc *Recursive) LookupNS(ctx context.Context, name string) (nslist []*net.NS, err error) <span class="cov0" title="0">{
        var msg *dns.Msg
        if msg, _, err = rc.DnsResolve(ctx, name, dns.TypeNS); err == nil </span><span class="cov0" title="0">{
                for _, rr := range msg.Answer </span><span class="cov0" title="0">{
                        switch rr := rr.(type) </span>{
                        case *dns.NS:<span class="cov0" title="0">
                                nslist = append(nslist, &amp;net.NS{Host: rr.Ns})</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

// func (std *Recursive) LookupAddr(ctx context.Context, addr string) ([]string, error)
// func (std *Recursive) LookupMX(ctx context.Context, name string) ([]*net.MX, error)
// func (std *Recursive) LookupPort(ctx context.Context, network, service string) (port int, err error)
// func (std *Recursive) LookupSRV(ctx context.Context, service, proto, name string) (string, []*net.SRV, error)
// func (std *Recursive) LookupTXT(ctx context.Context, name string) ([]string, error)
</pre>
		
		<pre class="file" id="file6" style="display: none">package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "maps"
        "net"
        "net/netip"
        "slices"
        "strings"
        "time"

        "github.com/miekg/dns"
)

const (
        cacheExtra = true // set to false to debug glue lookups
)

type query struct {
        *Recursive
        start  time.Time
        cache  Cacher
        logw   io.Writer
        depth  int
        nomini bool
        sent   int
        steps  int
        glue   map[string][]netip.Addr
        cnames map[string]struct{}
}

func (q *query) dbg() bool <span class="cov0" title="0">{
        return q.logw != nil
}</span>

func (q *query) log(format string, args ...any) bool <span class="cov0" title="0">{
        fmt.Fprintf(q.logw, "[%-5d %2d] %*s", time.Since(q.start).Milliseconds(), q.depth, q.depth, "")
        fmt.Fprintf(q.logw, format, args...)
        return false
}</span>

type hostAddr struct {
        host string
        addr netip.Addr
}

func (ha hostAddr) String() (s string) <span class="cov0" title="0">{
        s = ha.host
        if ha.addr.IsValid() </span><span class="cov0" title="0">{
                s += " " + ha.addr.String()
        }</span>
        <span class="cov0" title="0">return</span>
}

// needGlue returns true if the host was added to the glue map
func (q *query) needGlue(host string) (yes bool) <span class="cov0" title="0">{
        if _, ok := q.glue[host]; !ok </span><span class="cov0" title="0">{
                yes = true
                q.glue[host] = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

// addGlue adds the addr to the glue map for host if it exists and addr is usable
func (q *query) addGlue(host string, addr netip.Addr) <span class="cov0" title="0">{
        if q.useable(addr) </span><span class="cov0" title="0">{
                if addrs, ok := q.glue[host]; ok </span><span class="cov0" title="0">{
                        if !slices.Contains(addrs, addr) </span><span class="cov0" title="0">{
                                q.glue[host] = append(addrs, addr)
                        }</span>
                }
        }
}

func (q *query) setCache(msg *dns.Msg) <span class="cov0" title="0">{
        if msg != nil &amp;&amp; !msg.Zero </span><span class="cov0" title="0">{
                if q.cache != nil &amp;&amp; !q.nomini </span><span class="cov0" title="0">{
                        q.cache.DnsSet(msg)
                }</span>
        }
}

func (q *query) glueTypes() (gt []uint16) <span class="cov0" title="0">{
        if q.useIPv4 </span><span class="cov0" title="0">{
                gt = append(gt, dns.TypeA)
        }</span>
        <span class="cov0" title="0">if q.useIPv6 </span><span class="cov0" title="0">{
                gt = append(gt, dns.TypeAAAA)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (q *query) run(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov0" title="0">{
        if err = q.dive(); err == nil </span><span class="cov0" title="0">{
                defer q.surface()

                var nslist []hostAddr // current set of servers to query
                var final bool        // past the last part of the name
                var idx int           // start of current label
                var qlabel int        // label to query for, starting from the right

                qname = dns.CanonicalName(qname)
                nslist = q.getRootServers()

                for !final </span><span class="cov0" title="0">{
                        qlabel++
                        idx, final = dns.PrevLabel(qname, qlabel)
                        cqname := qname[idx:] // current name to ask for
                        cqtype := dns.TypeNS  // current type to ask for
                        if q.nomini </span><span class="cov0" title="0">{
                                cqname = qname
                                cqtype = qtype
                        }</span>
                        <span class="cov0" title="0">if _, ok := q.glue[qname]; ok </span><span class="cov0" title="0">{
                                cqtype = qtype
                        }</span>

                        <span class="cov0" title="0">if q.dbg() </span><span class="cov0" title="0">{
                                var finaltext string
                                if final </span><span class="cov0" title="0">{
                                        finaltext = " FINAL"
                                }</span>
                                <span class="cov0" title="0">q.log("QUERY%s %s %q from %v\n", finaltext, DnsTypeToString(cqtype), cqname, nslist[:min(4, len(nslist))])</span>
                        }

                        <span class="cov0" title="0">var nsrcode int     // RCODE from last nameserver A query resolving glueless names
                        var gotmsg *dns.Msg // last valid response
                trynextnameserver:
                        for _, ha := range nslist </span><span class="cov0" title="0">{
                                if !ha.addr.IsValid() </span><span class="cov0" title="0">{
                                        if q.needGlue(ha.host) </span><span class="cov0" title="0">{
                                                _ = q.dbg() &amp;&amp; q.log("GLUE lookup for NS %q\n", ha.host)
                                                for _, gluetype := range q.glueTypes() </span><span class="cov0" title="0">{
                                                        var m *dns.Msg
                                                        if m, _, err = q.run(ctx, ha.host, gluetype); err == nil </span><span class="cov0" title="0">{
                                                                nsrcode = m.Rcode
                                                                if m.Rcode == dns.RcodeSuccess </span><span class="cov0" title="0">{
                                                                        for _, rr := range m.Answer </span><span class="cov0" title="0">{
                                                                                if host, addr := rrHostAddr(rr); host == ha.host </span><span class="cov0" title="0">{
                                                                                        ha.addr = addr
                                                                                        q.addGlue(host, addr)
                                                                                }</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                                <span class="cov0" title="0">if q.useable(ha.addr) </span><span class="cov0" title="0">{
                                        if gotmsg, err = q.exchange(ctx, ha.addr, cqname, cqtype); err == nil </span><span class="cov0" title="0">{
                                                switch gotmsg.Rcode </span>{
                                                case dns.RcodeSuccess:<span class="cov0" title="0">
                                                        if gotmsg.Authoritative || (idx &gt; 0 &amp;&amp; (gotmsg.Rcode == dns.RcodeNameError || len(gotmsg.Answer) &gt; 0)) </span><span class="cov0" title="0">{
                                                                q.setCache(gotmsg)
                                                        }</span>
                                                        <span class="cov0" title="0">newlist := q.extractNS(gotmsg)
                                                        if len(newlist) &gt; 0 </span><span class="cov0" title="0">{
                                                                srv = ha.addr
                                                                msg = gotmsg
                                                                nslist = newlist
                                                        }</span>
                                                case dns.RcodeServerFailure:<span class="cov0" title="0">
                                                        if final </span><span class="cov0" title="0">{
                                                                q.setCache(gotmsg)
                                                                srv = ha.addr
                                                                msg = gotmsg
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">msg = nil
                                                        srv = ha.addr
                                                        continue trynextnameserver</span>
                                                case dns.RcodeRefused:<span class="cov0" title="0">
                                                        if !q.nomini </span><span class="cov0" title="0">{
                                                                _ = q.dbg() &amp;&amp; q.log("got REFUSED, retry without QNAME minimization\n")
                                                                q.nomini = true
                                                                msg, srv, err = q.run(ctx, qname, qtype)
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">fallthrough</span>
                                                default:<span class="cov0" title="0">
                                                        q.setCache(gotmsg)
                                                        srv = ha.addr
                                                        msg = gotmsg
                                                        return</span>
                                                }
                                                <span class="cov0" title="0">break</span> // next qlabel
                                        }
                                }
                        }

                        // asked all nameservers or got a usable answer
                        <span class="cov0" title="0">if gotmsg == nil </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("no ANSWER for %s %q (%s)\n", DnsTypeToString(qtype), qname, dns.RcodeToString[nsrcode])
                                if msg != nil </span><span class="cov0" title="0">{
                                        if qtype == dns.TypeNS </span><span class="cov0" title="0">{
                                                if len(msg.Answer) == 0 </span><span class="cov0" title="0">{
                                                        if len(msg.Question) &gt; 0 &amp;&amp; msg.Question[0].Name == qname </span><span class="cov0" title="0">{
                                                                msg.Answer, msg.Ns = msg.Ns, msg.Answer
                                                        }</span> else<span class="cov0" title="0"> {
                                                                msg.Rcode = nsrcode
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                if nsrcode != dns.RcodeSuccess </span><span class="cov0" title="0">{
                                                        msg.SetQuestion(qname, qtype)
                                                        msg.Rcode = nsrcode
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        err = errors.Join(err, ErrNoResponse)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if msg == nil </span><span class="cov0" title="0">{
                                        _ = q.dbg() &amp;&amp; q.log("all nameservers returned SERVFAIL\n")
                                        q.setCache(gotmsg)
                                        msg = gotmsg
                                }</span>
                        }
                }

                // ask the final nameserves for the record
                <span class="cov0" title="0">if msg != nil </span><span class="cov0" title="0">{
                        var nsaddrs []netip.Addr
                        for _, ha := range nslist </span><span class="cov0" title="0">{
                                if ha.addr.IsValid() </span><span class="cov0" title="0">{
                                        nsaddrs = append(nsaddrs, ha.addr)
                                }</span> else<span class="cov0" title="0"> {
                                        nsaddrs = append(nsaddrs, q.glue[ha.host]...)
                                }</span>
                        }
                        <span class="cov0" title="0">slices.SortFunc(nsaddrs, func(a, b netip.Addr) int </span><span class="cov0" title="0">{ return a.Compare(b) }</span>)
                        <span class="cov0" title="0">nsaddrs = slices.Compact(nsaddrs)
                        if q.dbg() </span><span class="cov0" title="0">{
                                q.log("final nameservers: %v\n", nsaddrs)
                                if q.depth == 1 </span><span class="cov0" title="0">{
                                        keys := slices.Collect(maps.Keys(q.glue))
                                        slices.Sort(keys)
                                        for _, k := range keys </span><span class="cov0" title="0">{
                                                q.log("glue: %q: %v\n", k, q.glue[k])
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">for _, nsaddr := range nsaddrs </span><span class="cov0" title="0">{
                                var finalmsg *dns.Msg
                                if finalmsg, err = q.exchange(ctx, nsaddr, qname, qtype); err == nil &amp;&amp; finalmsg.Rcode != dns.RcodeServerFailure </span><span class="cov0" title="0">{
                                        msg = finalmsg
                                        q.setCache(msg)
                                        if qtype != dns.TypeCNAME </span><span class="cov0" title="0">{
                                                for _, rr := range msg.Answer </span><span class="cov0" title="0">{
                                                        if cn, ok := rr.(*dns.CNAME); ok </span><span class="cov0" title="0">{
                                                                target := dns.CanonicalName(cn.Target)
                                                                if q.followCNAME(target) </span><span class="cov0" title="0">{
                                                                        _ = q.dbg() &amp;&amp; q.log("CNAME QUERY %q =&gt; %q\n", qname, target)
                                                                        if cnmsg, _, cnerr := q.run(ctx, target, qtype); cnerr == nil </span><span class="cov0" title="0">{
                                                                                _ = q.dbg() &amp;&amp; q.log("CNAME ANSWER %s %q with %v records\n", dns.RcodeToString[cnmsg.Rcode], target, len(cnmsg.Answer))
                                                                                msg = msg.Copy()
                                                                                msg.Zero = true
                                                                                msg.Answer = append(msg.Answer, cnmsg.Answer...)
                                                                                msg.Rcode = cnmsg.Rcode
                                                                                return
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                _ = q.dbg() &amp;&amp; q.log("CNAME ERROR %q: %v\n", target, cnerr)
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">break</span>
                                } else<span class="cov0" title="0"> {
                                        _ = q.dbg() &amp;&amp; q.log("FAILED @%v %s %q: %v\n", nsaddr, DnsTypeToString(qtype), qname, err)
                                }</span>
                        }
                        <span class="cov0" title="0">if err != nil || len(nsaddrs) == 0 </span><span class="cov0" title="0">{
                                // all final nameservers failed to be queried,
                                // so don't use the last NS message unless usable
                                if msg == nil || qtype != dns.TypeNS || qname != msg.Question[0].Name </span><span class="cov0" title="0">{
                                        msg = nil
                                }</span>
                        }
                }

                <span class="cov0" title="0">if msg == nil </span><span class="cov0" title="0">{
                        // manufacture a SERVFAIL
                        msg = new(dns.Msg)
                        msg.SetQuestion(qname, qtype)
                        msg.Rcode = dns.RcodeServerFailure
                }</span> else<span class="cov0" title="0"> {
                        // we got a message to return, disregard network errors
                        err = nil
                }</span>

                <span class="cov0" title="0">_ = q.dbg() &amp;&amp; q.log("ANSWER %s for %s %q with %d records\n",
                        dns.RcodeToString[msg.Rcode],
                        DnsTypeToString(qtype), qname,
                        len(msg.Answer))</span>
        }
        <span class="cov0" title="0">return</span>
}

func rrHostAddr(rr dns.RR) (host string, addr netip.Addr) <span class="cov0" title="0">{
        switch v := rr.(type) </span>{
        case *dns.A:<span class="cov0" title="0">
                if ip, ok := netip.AddrFromSlice(v.A); ok </span><span class="cov0" title="0">{
                        host = dns.CanonicalName(v.Hdr.Name)
                        addr = ip.Unmap()
                }</span>
        case *dns.AAAA:<span class="cov0" title="0">
                if ip, ok := netip.AddrFromSlice(v.AAAA); ok </span><span class="cov0" title="0">{
                        host = dns.CanonicalName(v.Hdr.Name)
                        addr = ip
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (q *query) extractNS(msg *dns.Msg) (hal []hostAddr) <span class="cov0" title="0">{
        nsmap := map[string]struct{}{}
        for _, rrs := range [][]dns.RR{msg.Answer, msg.Ns} </span><span class="cov0" title="0">{
                for _, rr := range rrs </span><span class="cov0" title="0">{
                        switch rr := rr.(type) </span>{
                        case *dns.NS:<span class="cov0" title="0">
                                host := dns.CanonicalName(rr.Ns)
                                nsmap[host] = struct{}{}</span>
                        }
                        <span class="cov0" title="0">host, addr := rrHostAddr(rr)
                        q.addGlue(host, addr)</span>
                }
        }
        <span class="cov0" title="0">for _, rr := range msg.Extra </span><span class="cov0" title="0">{
                host, addr := rrHostAddr(rr)
                if _, ok := nsmap[host]; ok </span><span class="cov0" title="0">{
                        q.needGlue(host)
                        q.addGlue(host, addr)
                }</span>
        }
        <span class="cov0" title="0">for host := range nsmap </span><span class="cov0" title="0">{
                addrs := q.glue[host]
                if len(addrs) == 0 </span><span class="cov0" title="0">{
                        hal = append(hal, hostAddr{host: host})
                }</span> else<span class="cov0" title="0"> {
                        for _, addr := range addrs </span><span class="cov0" title="0">{
                                hal = append(hal, hostAddr{host: host, addr: addr})
                        }</span>
                }
        }
        // Make the NS query order deterministic.
        <span class="cov0" title="0">slices.SortFunc(hal, func(a, b hostAddr) int </span><span class="cov0" title="0">{
                if a.addr.IsValid() </span><span class="cov0" title="0">{
                        if b.addr.IsValid() </span><span class="cov0" title="0">{
                                return a.addr.Compare(b.addr)
                        }</span>
                        <span class="cov0" title="0">return -1</span>
                }
                <span class="cov0" title="0">if b.addr.IsValid() </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">n := strings.Count(a.host, ".") - strings.Count(b.host, ".")
                if n == 0 </span><span class="cov0" title="0">{
                        n = strings.Compare(a.host, b.host)
                }</span>
                <span class="cov0" title="0">return n</span>
        })
        <span class="cov0" title="0">return</span>
}

func (q *query) dive() (err error) <span class="cov0" title="0">{
        err = ErrMaxDepth
        if q.depth &lt; maxDepth </span><span class="cov0" title="0">{
                q.depth++
                err = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (q *query) surface() <span class="cov0" title="0">{
        q.depth--
}</span>

func (q *query) followCNAME(cn string) bool <span class="cov0" title="0">{
        if q.cnames == nil </span><span class="cov0" title="0">{
                q.cnames = make(map[string]struct{})
        }</span>
        <span class="cov0" title="0">_, ok := q.cnames[cn]
        if !ok </span><span class="cov0" title="0">{
                q.cnames[cn] = struct{}{}
        }</span>
        <span class="cov0" title="0">return !ok</span>
}

func (q *query) exchangeUsing(ctx context.Context, protocol string, useCookies bool, nsaddr netip.Addr, qname string, qtype uint16) (msg *dns.Msg, err error) <span class="cov0" title="0">{
        q.steps++
        if q.steps &gt; maxSteps </span><span class="cov0" title="0">{
                err = ErrMaxDepth
                return
        }</span>
        <span class="cov0" title="0">if q.cache != nil &amp;&amp; !q.nomini </span><span class="cov0" title="0">{
                if msg = q.cache.DnsGet(qname, qtype); msg != nil </span><span class="cov0" title="0">{
                        if !cacheExtra </span><span class="cov0" title="0">{
                                msg.Extra = nil
                        }</span>
                        <span class="cov0" title="0">if q.dbg() </span><span class="cov0" title="0">{
                                auth := ""
                                if msg.MsgHdr.Authoritative </span><span class="cov0" title="0">{
                                        auth = " AUTH"
                                }</span>
                                <span class="cov0" title="0">q.log("cached answer: %s %q =&gt; %s [%v+%v+%v A/N/E]%s\n",
                                        DnsTypeToString(qtype), qname,
                                        dns.RcodeToString[msg.Rcode],
                                        len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                        auth,
                                )</span>
                        }
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">if err = q.getUsable(ctx, protocol, nsaddr); err == nil </span><span class="cov0" title="0">{
                var network string
                if nsaddr.Is4() </span><span class="cov0" title="0">{
                        network = protocol + "4"
                }</span> else<span class="cov0" title="0"> {
                        network = protocol + "6"
                }</span>

                <span class="cov0" title="0">if q.rateLimiter != nil </span><span class="cov0" title="0">{
                        &lt;-q.rateLimiter
                }</span>

                <span class="cov0" title="0">if q.dbg() </span><span class="cov0" title="0">{
                        var protostr string
                        var dash6str string
                        if protocol != "udp" </span><span class="cov0" title="0">{
                                protostr = " +" + protocol
                        }</span>
                        <span class="cov0" title="0">if nsaddr.Is6() </span><span class="cov0" title="0">{
                                dash6str = " -6"
                        }</span>
                        <span class="cov0" title="0">q.log("SENDING %s: @%s%s%s %s %q", network, nsaddr, protostr, dash6str, DnsTypeToString(qtype), qname)</span>
                }

                <span class="cov0" title="0">var nconn net.Conn
                var rtt time.Duration

                if q.Timeout &gt; 0 </span><span class="cov0" title="0">{
                        ctx2, cancel := context.WithTimeout(ctx, q.Timeout)
                        defer cancel()
                        ctx = ctx2
                }</span>

                <span class="cov0" title="0">if nconn, err = q.DialContext(ctx, network, netip.AddrPortFrom(nsaddr, 53).String()); err == nil </span><span class="cov0" title="0">{
                        q.sent++
                        dnsconn := &amp;dns.Conn{Conn: nconn, UDPSize: dns.DefaultMsgSize}
                        defer dnsconn.Close()

                        m := new(dns.Msg)
                        m.SetQuestion(qname, qtype)
                        opt := new(dns.OPT)
                        opt.Hdr.Name = "."
                        opt.Hdr.Rrtype = dns.TypeOPT
                        opt.SetUDPSize(dns.DefaultMsgSize)

                        var hasSrvCookie bool
                        var clicookie, srvcookie string

                        if useCookies </span><span class="cov0" title="0">{
                                q.mu.RLock()
                                clicookie = q.clicookie
                                srvcookie, hasSrvCookie = q.srvcookies[nsaddr]
                                q.mu.RUnlock()

                                useCookies = !hasSrvCookie || srvcookie != ""

                                if useCookies </span><span class="cov0" title="0">{
                                        opt.Option = append(opt.Option, &amp;dns.EDNS0_COOKIE{
                                                Code:   dns.EDNS0COOKIE,
                                                Cookie: clicookie + srvcookie,
                                        })
                                        if q.logw != nil </span><span class="cov0" title="0">{
                                                fmt.Fprintf(q.logw, " COOKIE:%q", clicookie+srvcookie)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">m.Extra = append(m.Extra, opt)
                        c := dns.Client{UDPSize: dns.DefaultMsgSize}
                        msg, rtt, err = c.ExchangeWithConnContext(ctx, m, dnsconn)
                        if useCookies &amp;&amp; msg != nil </span><span class="cov0" title="0">{
                                newsrvcookie := srvcookie
                                if opt := msg.IsEdns0(); opt != nil </span><span class="cov0" title="0">{
                                        for _, rr := range opt.Option </span><span class="cov0" title="0">{
                                                switch rr := rr.(type) </span>{
                                                case *dns.EDNS0_COOKIE:<span class="cov0" title="0">
                                                        if strings.HasPrefix(rr.Cookie, clicookie) </span><span class="cov0" title="0">{
                                                                newsrvcookie = strings.TrimPrefix(rr.Cookie, clicookie)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                msg = nil
                                                                err = ErrInvalidCookie
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov0" title="0">if !hasSrvCookie || srvcookie != newsrvcookie </span><span class="cov0" title="0">{
                                        q.mu.Lock()
                                        q.srvcookies[nsaddr] = newsrvcookie
                                        q.mu.Unlock()
                                }</span>
                        }
                }

                <span class="cov0" title="0">isIpv6Err, isUdpErr := q.setNetError(protocol, nsaddr, err)
                ipv6disabled := isIpv6Err &amp;&amp; q.maybeDisableIPv6(err)
                udpDisabled := isUdpErr &amp;&amp; q.maybeDisableUdp(err)

                if q.logw != nil </span><span class="cov0" title="0">{
                        if msg != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " =&gt; %s [%v+%v+%v A/N/E] (%v, %d bytes",
                                        dns.RcodeToString[msg.Rcode],
                                        len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                        rtt.Round(time.Millisecond), msg.Len())
                                if msg.MsgHdr.Truncated </span><span class="cov0" title="0">{
                                        fmt.Fprintf(q.logw, " TRNC")
                                }</span>
                                <span class="cov0" title="0">if msg.MsgHdr.Authoritative </span><span class="cov0" title="0">{
                                        fmt.Fprintf(q.logw, " AUTH")
                                }</span>
                                <span class="cov0" title="0">if opt := msg.IsEdns0(); opt != nil </span><span class="cov0" title="0">{
                                        if er := uint16(opt.ExtendedRcode()); /*#nosec G115*/ er != 0 </span><span class="cov0" title="0">{
                                                fmt.Fprintf(q.logw, " EDNS=%s", dns.ExtendedErrorCodeToString[er])
                                        }</span>
                                }
                                <span class="cov0" title="0">fmt.Fprintf(q.logw, ")")</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " error: %v", err)
                        }</span>
                        <span class="cov0" title="0">if ipv6disabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (IPv6 disabled)")
                        }</span>
                        <span class="cov0" title="0">if udpDisabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (UDP disabled)")
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(q.logw)</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (q *query) exchange(ctx context.Context, nsaddr netip.Addr, qname string, qtype uint16) (msg *dns.Msg, err error) <span class="cov0" title="0">{
        useCookies := true
        if q.usingUDP() </span><span class="cov0" title="0">{
                msg, err = q.exchangeUsing(ctx, "udp", useCookies, nsaddr, qname, qtype)
                if msg != nil </span><span class="cov0" title="0">{
                        if msg.MsgHdr.Truncated </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("message truncated; retry using TCP\n")
                                msg = nil
                        }</span> else<span class="cov0" title="0"> if msg.MsgHdr.Rcode == dns.RcodeFormatError </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("got FORMERR, retry using TCP without cookies\n")
                                msg = nil
                                useCookies = false
                        }</span>
                }
        }
        <span class="cov0" title="0">if (msg == nil || err != nil) &amp;&amp; q.useable(nsaddr) </span><span class="cov0" title="0">{
                msg, err = q.exchangeUsing(ctx, "tcp", useCookies, nsaddr, qname, qtype)
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "math/rand/v2"
        "net"
        "net/netip"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/miekg/dns"
        "golang.org/x/net/proxy"
)

/*
        Good tests:
        NS        google.tw.cn.
        NS        bankgirot.nu.
        NS        skandia.com.ci.
        A        m.hkirc.net.hk.
        A        www.microsoft.com.
        A   console.aws.amazon.com.
        A   *.en.se.
        A        teli.se.
        A        telia.biz.mv.
        A        telia.per.la.
        NS        seb.inf.ua
        A        seb.org.tw
        NS        wetrgijrotigj.bet.ar
        A        h6xyrckrof16xv31.xn--kprw13d
        MX        3sj82qujmol2npax.us.kg
        A        9ghuun5oshdr6hvi.prd.mg
        NS        5xqy3o9qafuvdqtv.mil.sy
        A        eoh.be
        NS        tella.net.ms
*/

//go:generate go run ./cmd/genhints roothints.gen.go

const (
        maxDepth        = 32   // maximum recursion depth
        maxRootAttempts = 2    // maximum number of root servers to try
        maxSteps        = 1000 // max number of steps to allow in resolving
)

var (
        // ErrInvalidCookie is returned if the DNS cookie from the server is invalid.
        ErrInvalidCookie = errors.New("invalid cookie")
        // ErrMaxDepth is returned when recursive resolving exceeds the allowed limit.
        ErrMaxDepth = fmt.Errorf("recursion depth exceeded %d", maxDepth)
        // ErrNoResponse is returned when no authoritative server could be successfully queried.
        // It is equivalent to SERVFAIL.
        ErrNoResponse = errors.New("no authoritative response")
        // ErrQuestionMismatch is returned when the DNS response is not for what was queried.
        ErrQuestionMismatch = errors.New("question mismatch")
        DefaultCache        = NewCache()
        DefaultTimeout      = time.Second * 5
)

var _ Resolver = (*Recursive)(nil) // ensure we implement interface

type Recursive struct {
        proxy.ContextDialer                 // (read-only) ContextDialer passed to NewWithOptions
        Cacher                              // (read-only) Cacher passed to NewWithOptions
        *net.Resolver                       // (read-only) net.Resolver using our ContextDialer
        Timeout             time.Duration   // (read-only) dialing timeout, zero to disable
        rateLimiter         &lt;-chan struct{} // (read-only) rate limited passed to NewWithOptions
        DefaultLogWriter    io.Writer       // if not nil, write debug logs here unless overridden
        mu                  sync.RWMutex    // protects following
        useUDP              bool
        useIPv4             bool
        useIPv6             bool
        rootServers         []netip.Addr
        clicookie           string
        srvcookies          map[netip.Addr]string
        udperrs             map[netip.Addr]netError
        tcperrs             map[netip.Addr]netError
}

func makeCookie() string <span class="cov0" title="0">{
        return fmt.Sprintf("%016x", rand.Uint64()) //#nosec G404
}</span>

// NewWithOptions returns a new Recursive resolver using the given ContextDialer and
// using the given Cacher as it's default cache. It does not call OrderRoots.
//
// Passing nil for dialer will use a net.Dialer.
// Passing nil for cache means it won't use any cache by default.
// Passing nil for the roots will use the default set of roots.
// Passing nil for the rateLimiter means no rate limiting
func NewWithOptions(dialer proxy.ContextDialer, cache Cacher, roots4, roots6 []netip.Addr, rateLimiter &lt;-chan struct{}) *Recursive <span class="cov0" title="0">{
        if dialer == nil </span><span class="cov0" title="0">{
                dialer = &amp;net.Dialer{}
        }</span>
        <span class="cov0" title="0">if roots4 == nil </span><span class="cov0" title="0">{
                roots4 = Roots4
        }</span>
        <span class="cov0" title="0">if roots6 == nil </span><span class="cov0" title="0">{
                roots6 = Roots6
        }</span>

        <span class="cov0" title="0">var root4, root6 []netip.Addr
        if len(roots4) &gt; 0 </span><span class="cov0" title="0">{
                root4 = append(root4, roots4...)
                rand.Shuffle(len(root4), func(i, j int) </span><span class="cov0" title="0">{ root4[i], root4[j] = root4[j], root4[i] }</span>)
        }
        <span class="cov0" title="0">if len(roots6) &gt; 0 </span><span class="cov0" title="0">{
                root6 = append(root6, roots6...)
                rand.Shuffle(len(root6), func(i, j int) </span><span class="cov0" title="0">{ root6[i], root6[j] = root6[j], root6[i] }</span>)
        }

        <span class="cov0" title="0">roots := make([]netip.Addr, 0, len(root4)+len(root6))
        n := min(len(root4), len(root6))
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                roots = append(roots, root4[i], root6[i])
        }</span>
        <span class="cov0" title="0">roots = append(roots, root4[n:]...)
        roots = append(roots, root6[n:]...)

        return &amp;Recursive{
                ContextDialer: dialer,
                Cacher:        cache,
                Resolver: &amp;net.Resolver{
                        PreferGo: true,
                        Dial:     dialer.DialContext,
                },
                Timeout:     DefaultTimeout,
                rateLimiter: rateLimiter,
                useUDP:      true,
                useIPv4:     len(root4) &gt; 0,
                useIPv6:     len(root6) &gt; 0,
                rootServers: roots,
                clicookie:   makeCookie(),
                srvcookies:  make(map[netip.Addr]string),
                udperrs:     make(map[netip.Addr]netError),
                tcperrs:     make(map[netip.Addr]netError),
        }</span>
}

// New returns a new Recursive resolver using the given ContextDialer and
// has DefaultCache as it's cache.
//
// It calls OrderRoots before returning.
func New(dialer proxy.ContextDialer) *Recursive <span class="cov0" title="0">{
        r := NewWithOptions(dialer, DefaultCache, nil, nil, nil)
        r.OrderRoots(context.Background())
        return r
}</span>

// ResetCookies generates a new DNS client cookie and clears the known DNS server cookies.
func (r *Recursive) ResetCookies() <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.clicookie = makeCookie()
        clear(r.srvcookies)
}</span>

// OrderRoots sorts the root server list by their current latency and removes those that don't respond.
//
// If ctx does not have a deadline, DefaultTimeout will be used.
func (r *Recursive) OrderRoots(ctx context.Context) <span class="cov0" title="0">{
        if _, ok := ctx.Deadline(); !ok </span><span class="cov0" title="0">{
                newctx, cancel := context.WithTimeout(ctx, DefaultTimeout)
                defer cancel()
                ctx = newctx
        }</span>
        <span class="cov0" title="0">r.mu.Lock()
        defer r.mu.Unlock()
        var l []*rootRtt
        var wg sync.WaitGroup
        for _, addr := range r.rootServers </span><span class="cov0" title="0">{
                rt := &amp;rootRtt{addr: addr}
                l = append(l, rt)
                wg.Add(1)
                go timeRoot(ctx, r, &amp;wg, rt)
        }</span>
        <span class="cov0" title="0">wg.Wait()
        sort.Slice(l, func(i, j int) bool </span><span class="cov0" title="0">{ return l[i].rtt &lt; l[j].rtt }</span>)
        <span class="cov0" title="0">var newRootServers []netip.Addr
        useIPv4 := false
        useIPv6 := false
        for _, rt := range l </span><span class="cov0" title="0">{
                if rt.rtt &lt; time.Minute </span><span class="cov0" title="0">{
                        useIPv4 = useIPv4 || rt.addr.Is4()
                        useIPv6 = useIPv6 || rt.addr.Is6()
                        newRootServers = append(newRootServers, rt.addr)
                }</span>
        }
        <span class="cov0" title="0">if len(newRootServers) &gt; 0 </span><span class="cov0" title="0">{
                r.rootServers = newRootServers
                r.useIPv4 = useIPv4
                r.useIPv6 = useIPv6
        }</span>
}

// ResolveWithOptions performs a recursive DNS resolution for the provided name and record type.
//
// If cache is nil, no cache is used. If logw is non-nil (or DefaultLogWriter is set), write a log of events.
func (r *Recursive) ResolveWithOptions(ctx context.Context, cache Cacher, logw io.Writer, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov0" title="0">{
        if logw == nil </span><span class="cov0" title="0">{
                logw = r.DefaultLogWriter
        }</span>
        <span class="cov0" title="0">var q *query
        qname = dns.CanonicalName(qname)
        if cache != nil </span><span class="cov0" title="0">{
                msg = cache.DnsGet(qname, qtype)
        }</span>
        <span class="cov0" title="0">if msg == nil </span><span class="cov0" title="0">{
                q = &amp;query{
                        Recursive: r,
                        cache:     cache,
                        start:     time.Now(),
                        logw:      logw,
                        glue:      make(map[string][]netip.Addr),
                }
                msg, srv, err = q.run(ctx, qname, qtype)
        }</span>
        <span class="cov0" title="0">if msg != nil </span><span class="cov0" title="0">{
                if msg.Rcode == dns.RcodeSuccess </span><span class="cov0" title="0">{
                        // A SUCCESS reply must reference the correct QNAME and QTYPE.
                        var gotname string
                        var gottype uint16
                        if len(msg.Question) &gt; 0 </span><span class="cov0" title="0">{
                                gotname = msg.Question[0].Name
                                gottype = msg.Question[0].Qtype
                        }</span>
                        <span class="cov0" title="0">if gotname != qname || gottype != qtype </span><span class="cov0" title="0">{
                                err = ErrQuestionMismatch
                                _ = q.dbg() &amp;&amp; q.log("ERROR: ANSWER was for %s %q, not %s %q\n",
                                        DnsTypeToString(gottype), gotname,
                                        DnsTypeToString(qtype), qname,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        if !msg.Zero </span><span class="cov0" title="0">{
                                // NXDOMAIN or other failures may have the returned
                                // question refer to some NS in the chain, but we still want
                                // to associate the reply with the original query.
                                msg.SetQuestion(qname, qtype)
                        }</span>
                }
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        cache.DnsSet(msg)
                }</span>
        }
        <span class="cov0" title="0">if logw != nil </span><span class="cov0" title="0">{
                if msg != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(logw, "\n%v", msg)
                }</span>
                <span class="cov0" title="0">if q != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(logw, "\n;; Sent %v queries in %v", q.sent, time.Since(q.start).Round(time.Millisecond))
                }</span>
                <span class="cov0" title="0">if srv.IsValid() </span><span class="cov0" title="0">{
                        fmt.Fprintf(logw, "\n;; SERVER: %v", srv)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(logw, "\n;; ERROR: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(logw)</span>
        }
        <span class="cov0" title="0">return</span>
}

// DnsResolve performs a recursive DNS resolution for the provided name and record type.
func (r *Recursive) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov0" title="0">{
        return r.ResolveWithOptions(ctx, r, nil, qname, qtype)
}</span>

func (r *Recursive) getRootServers() (nslist []hostAddr) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov0" title="0">{
                nslist = append(nslist, hostAddr{"root", addr})
        }</span>
        <span class="cov0" title="0">return</span>
}

// Roots returns the current set of root servers in use.
func (r *Recursive) GetRoots() (root4, root6 []netip.Addr) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov0" title="0">{
                if addr.Is4() </span><span class="cov0" title="0">{
                        root4 = append(root4, addr)
                }</span>
                <span class="cov0" title="0">if addr.Is6() </span><span class="cov0" title="0">{
                        root6 = append(root6, addr)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (r *Recursive) usingUDP() (yes bool) <span class="cov0" title="0">{
        r.mu.RLock()
        yes = r.useUDP
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) useable(addr netip.Addr) (ok bool) <span class="cov0" title="0">{
        if addr.IsValid() </span><span class="cov0" title="0">{
                r.mu.RLock()
                ok = (r.useIPv4 &amp;&amp; addr.Is4()) || (r.useIPv6 &amp;&amp; addr.Is6())
                r.mu.RUnlock()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (r *Recursive) setNetError(protocol string, nsaddr netip.Addr, err error) (isIpv6err, isUdpErr bool) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                isIpv6err = nsaddr.Is6()
                _, ok := err.(net.Error)
                ok = ok || errors.Is(err, io.EOF)
                ok = ok || strings.Contains(err.Error(), "timeout")
                ok = ok || strings.Contains(err.Error(), "refused")
                if ok </span><span class="cov0" title="0">{
                        var m map[netip.Addr]netError
                        switch protocol </span>{
                        case "udp":<span class="cov0" title="0">
                                isUdpErr = true
                                m = r.udperrs</span>
                        case "tcp":<span class="cov0" title="0">
                                m = r.tcperrs</span>
                        }
                        <span class="cov0" title="0">if m != nil </span><span class="cov0" title="0">{
                                r.mu.Lock()
                                m[nsaddr] = netError{Err: err, When: time.Now()}
                                r.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (r *Recursive) getUsable(ctx context.Context, protocol string, nsaddr netip.Addr) (err error) <span class="cov0" title="0">{
        if err = ctx.Err(); err == nil </span><span class="cov0" title="0">{
                var m map[netip.Addr]netError
                switch protocol </span>{
                case "udp", "udp4", "udp6":<span class="cov0" title="0">
                        m = r.udperrs</span>
                case "tcp", "tcp4", "tcp6":<span class="cov0" title="0">
                        m = r.tcperrs</span>
                }
                <span class="cov0" title="0">err = net.ErrClosed
                if m != nil </span><span class="cov0" title="0">{
                        r.mu.RLock()
                        ne, hasNetError := m[nsaddr]
                        if !hasNetError </span><span class="cov0" title="0">{
                                if (r.useIPv4 &amp;&amp; nsaddr.Is4()) || (r.useIPv6 &amp;&amp; nsaddr.Is6()) </span><span class="cov0" title="0">{
                                        err = nil
                                }</span>
                        }
                        <span class="cov0" title="0">r.mu.RUnlock()
                        if hasNetError </span><span class="cov0" title="0">{
                                err = ne
                                if time.Since(ne.When) &gt; time.Minute </span><span class="cov0" title="0">{
                                        err = nil
                                        r.mu.Lock()
                                        delete(m, nsaddr)
                                        r.mu.Unlock()
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

func (r *Recursive) maybeDisableIPv6(err error) (disabled bool) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                errstr := err.Error()
                if strings.Contains(errstr, "network is unreachable") || strings.Contains(errstr, "no route to host") </span><span class="cov0" title="0">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        if r.useIPv6 </span><span class="cov0" title="0">{
                                disabled = true
                                r.useIPv6 = false
                                var idx int
                                for i := range r.rootServers </span><span class="cov0" title="0">{
                                        if r.rootServers[i].Is4() </span><span class="cov0" title="0">{
                                                r.rootServers[idx] = r.rootServers[i]
                                                idx++
                                        }</span>
                                }
                                <span class="cov0" title="0">r.rootServers = r.rootServers[:idx]</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

func (r *Recursive) maybeDisableUdp(err error) (disabled bool) <span class="cov0" title="0">{
        if ne, ok := err.(net.Error); ok </span><span class="cov0" title="0">{
                if !ne.Timeout() &amp;&amp; strings.Contains(ne.Error(), "network not implemented") </span><span class="cov0" title="0">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        disabled = r.useUDP
                        r.useUDP = false
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sync"
        "time"

        "golang.org/x/net/proxy"
)

type rootRtt struct {
        addr netip.Addr
        rtt  time.Duration
}

func timeRoot(ctx context.Context, dialer proxy.ContextDialer, wg *sync.WaitGroup, rt *rootRtt) <span class="cov0" title="0">{
        defer wg.Done()
        const numProbes = 3
        network := "tcp4"
        if rt.addr.Is6() </span><span class="cov0" title="0">{
                network = "tcp6"
        }</span>
        <span class="cov0" title="0">rt.rtt = time.Hour
        var rtt time.Duration
        for i := 0; i &lt; numProbes; i++ </span><span class="cov0" title="0">{
                now := time.Now()
                conn, err := dialer.DialContext(ctx, network, netip.AddrPortFrom(rt.addr, 53).String())
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">rtt += time.Since(now)
                _ = conn.Close()</span>
        }
        <span class="cov0" title="0">rt.rtt = rtt / numProbes</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package recursive

import (
        "net/netip"
        "strconv"

        "github.com/miekg/dns"
)

func DnsTypeToString(qtype uint16) string <span class="cov0" title="0">{
        if s, ok := dns.TypeToString[qtype]; ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(int(qtype))</span>
}

func AddrFromRR(rr dns.RR) netip.Addr <span class="cov0" title="0">{
        switch v := rr.(type) </span>{
        case *dns.A:<span class="cov0" title="0">
                if ip, ok := netip.AddrFromSlice(v.A); ok </span><span class="cov0" title="0">{
                        return ip.Unmap()
                }</span>
        case *dns.AAAA:<span class="cov0" title="0">
                if ip, ok := netip.AddrFromSlice(v.AAAA); ok </span><span class="cov0" title="0">{
                        return ip
                }</span>
        }
        <span class="cov0" title="0">return netip.Addr{}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
