
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>recursive: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/recursive/cache.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/recursive/cacheqtype.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/recursive/neterror.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/recursive/netresolver.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/recursive/query.go (78.9%)</option>
				
				<option value="file5">github.com/linkdata/recursive/recursive.go (95.4%)</option>
				
				<option value="file6">github.com/linkdata/recursive/timeroot.go (100.0%)</option>
				
				<option value="file7">github.com/linkdata/recursive/util.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sync/atomic"
        "time"

        "github.com/miekg/dns"
)

const DefaultMinTTL = 10 * time.Second // ten seconds
const DefaultMaxTTL = 6 * time.Hour    // six hours
const DefaultNXTTL = time.Hour         // one hour
const MaxQtype = 260

var _ Cacher = (*Cache)(nil)
var _ Resolver = (*Cache)(nil)

type Cache struct {
        MinTTL time.Duration // always cache responses for at least this long
        MaxTTL time.Duration // never cache responses for longer than this (excepting successful NS responses)
        NXTTL  time.Duration // cache NXDOMAIN responses for this long
        count  atomic.Uint64
        hits   atomic.Uint64
        cq     []*cacheQtype
}

func NewCache() *Cache <span class="cov8" title="1">{
        cq := make([]*cacheQtype, MaxQtype+1)
        for i := range cq </span><span class="cov8" title="1">{
                cq[i] = newCacheQtype()
        }</span>
        <span class="cov8" title="1">return &amp;Cache{
                MinTTL: DefaultMinTTL,
                MaxTTL: DefaultMaxTTL,
                NXTTL:  DefaultNXTTL,
                cq:     cq,
        }</span>
}

// HitRatio returns the hit ratio as a percentage.
func (cache *Cache) HitRatio() (n float64) <span class="cov8" title="1">{
        if cache != nil </span><span class="cov8" title="1">{
                if count := cache.count.Load(); count &gt; 0 </span><span class="cov8" title="1">{
                        n = float64(cache.hits.Load()*100) / float64(count)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Entries returns the number of entries in the cache.
func (cache *Cache) Entries() (n int) <span class="cov8" title="1">{
        if cache != nil </span><span class="cov8" title="1">{
                for _, cq := range cache.cq </span><span class="cov8" title="1">{
                        n += cq.entries()
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (cache *Cache) DnsSet(msg *dns.Msg) <span class="cov8" title="1">{
        if cache != nil &amp;&amp; msg != nil &amp;&amp; !msg.Zero &amp;&amp; len(msg.Question) == 1 </span><span class="cov8" title="1">{
                if qtype := msg.Question[0].Qtype; qtype &lt;= MaxQtype </span><span class="cov8" title="1">{
                        msg = msg.Copy()
                        msg.Zero = true
                        ttl := cache.NXTTL
                        if msg.Rcode != dns.RcodeNameError </span><span class="cov8" title="1">{
                                ttl = max(cache.MinTTL, time.Duration(MinTTL(msg))*time.Second)
                                if qtype != dns.TypeNS || msg.Rcode != dns.RcodeSuccess </span><span class="cov8" title="1">{
                                        ttl = min(cache.MaxTTL, ttl)
                                }</span>
                        }
                        <span class="cov8" title="1">cache.cq[qtype].set(msg, ttl)</span>
                }
        }
}

func (cache *Cache) DnsGet(qname string, qtype uint16) (msg *dns.Msg) <span class="cov8" title="1">{
        if cache != nil </span><span class="cov8" title="1">{
                cache.count.Add(1)
                if qtype &lt;= MaxQtype </span><span class="cov8" title="1">{
                        if msg = cache.cq[qtype].get(qname); msg != nil </span><span class="cov8" title="1">{
                                cache.hits.Add(1)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (cache *Cache) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov8" title="1">{
        msg = cache.DnsGet(qname, qtype)
        return
}</span>

func (cache *Cache) Clear() <span class="cov8" title="1">{
        if cache != nil </span><span class="cov8" title="1">{
                for _, cq := range cache.cq </span><span class="cov8" title="1">{
                        cq.clear()
                }</span>
        }
}

func (cache *Cache) Clean() <span class="cov8" title="1">{
        if cache != nil </span><span class="cov8" title="1">{
                now := time.Now()
                for _, cq := range cache.cq </span><span class="cov8" title="1">{
                        cq.clean(now)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package recursive

import (
        "sync"
        "time"

        "github.com/miekg/dns"
)

type cacheQtype struct {
        mu    sync.RWMutex
        cache map[string]cacheValue
}

func newCacheQtype() *cacheQtype <span class="cov8" title="1">{
        return &amp;cacheQtype{cache: make(map[string]cacheValue)}
}</span>

func (cq *cacheQtype) entries() (n int) <span class="cov8" title="1">{
        cq.mu.RLock()
        n = len(cq.cache)
        cq.mu.RUnlock()
        return
}</span>

func (cq *cacheQtype) set(msg *dns.Msg, ttl time.Duration) <span class="cov8" title="1">{
        qname := msg.Question[0].Name
        expires := time.Now().Add(ttl)
        cq.mu.Lock()
        cq.cache[qname] = cacheValue{Msg: msg, expires: expires}
        cq.mu.Unlock()
}</span>

func (cq *cacheQtype) get(qname string) *dns.Msg <span class="cov8" title="1">{
        cq.mu.RLock()
        cv := cq.cache[qname]
        cq.mu.RUnlock()
        if cv.Msg != nil </span><span class="cov8" title="1">{
                if time.Since(cv.expires) &lt; 0 </span><span class="cov8" title="1">{
                        return cv.Msg
                }</span>
                <span class="cov8" title="1">cq.mu.Lock()
                delete(cq.cache, qname)
                cq.mu.Unlock()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (cq *cacheQtype) clear() <span class="cov8" title="1">{
        cq.clean(time.Time{})
}</span>

func (cq *cacheQtype) clean(now time.Time) <span class="cov8" title="1">{
        cq.mu.Lock()
        defer cq.mu.Unlock()
        for qname, cv := range cq.cache </span><span class="cov8" title="1">{
                if now.IsZero() || now.After(cv.expires) </span><span class="cov8" title="1">{
                        delete(cq.cache, qname)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package recursive

import "time"

type netError struct {
        Err  error
        When time.Time
}

func (ne netError) Error() string <span class="cov8" title="1">{
        return ne.Err.Error()
}</span>

func (ne netError) Unwrap() error <span class="cov8" title="1">{
        return ne.Err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package recursive

import (
        "context"
        "net"
        "net/netip"
        "slices"

        "github.com/miekg/dns"
)

// override some of the standard Go net.Resolver functions

func (rc *Recursive) lookupNetIP(ctx context.Context, host string, qtype uint16) (ips []net.IP, err error) <span class="cov8" title="1">{
        var msg *dns.Msg
        if msg, _, err = rc.dnsResolve(ctx, host, qtype); msg != nil </span><span class="cov8" title="1">{
                for _, rr := range msg.Answer </span><span class="cov8" title="1">{
                        switch rr := rr.(type) </span>{
                        case *dns.A:<span class="cov8" title="1">
                                ips = append(ips, rr.A)</span>
                        case *dns.AAAA:<span class="cov8" title="1">
                                ips = append(ips, rr.AAAA)</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (rc *Recursive) LookupIP(ctx context.Context, network, host string) (ips []net.IP, err error) <span class="cov8" title="1">{
        seen := map[string]struct{}{}
        add := func(list []net.IP) </span><span class="cov8" title="1">{
                for _, ip := range list </span><span class="cov8" title="1">{
                        key := ip.String()
                        if _, ok := seen[key]; !ok </span><span class="cov8" title="1">{
                                seen[key] = struct{}{}
                                ips = append(ips, ip)
                        }</span>
                }
        }
        <span class="cov8" title="1">if network == "ip" || network == "ip4" </span><span class="cov8" title="1">{
                var list []net.IP
                if list, err = rc.lookupNetIP(ctx, host, dns.TypeA); err == nil </span><span class="cov8" title="1">{
                        add(list)
                }</span>
        }
        <span class="cov8" title="1">if network == "ip" || network == "ip6" </span><span class="cov8" title="1">{
                var list []net.IP
                if list, err = rc.lookupNetIP(ctx, host, dns.TypeAAAA); err == nil </span><span class="cov8" title="1">{
                        add(list)
                }</span>
        }
        <span class="cov8" title="1">if len(ips) &gt; 0 </span><span class="cov8" title="1">{
                err = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rc *Recursive) LookupHost(ctx context.Context, host string) (addrs []string, err error) <span class="cov8" title="1">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov8" title="1">{
                for _, ip := range ips </span><span class="cov8" title="1">{
                        addrs = append(addrs, ip.String())
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (rc *Recursive) LookupNetIP(ctx context.Context, network, host string) (addrs []netip.Addr, err error) <span class="cov8" title="1">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov8" title="1">{
                for _, ip := range ips </span><span class="cov8" title="1">{
                        if ip, ok := netip.AddrFromSlice(ip); ok </span><span class="cov8" title="1">{
                                addrs = append(addrs, ip)
                        }</span>
                }
                <span class="cov8" title="1">slices.SortFunc(addrs, func(a, b netip.Addr) int </span><span class="cov8" title="1">{ return a.Compare(b) }</span>)
                <span class="cov8" title="1">addrs = slices.Compact(addrs)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (rc *Recursive) LookupIPAddr(ctx context.Context, host string) (addrs []net.IPAddr, err error) <span class="cov8" title="1">{
        var ips []net.IP
        if ips, err = rc.LookupIP(ctx, "ip", host); err == nil </span><span class="cov8" title="1">{
                for _, ip := range ips </span><span class="cov8" title="1">{
                        addrs = append(addrs, net.IPAddr{IP: ip})
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (rc *Recursive) LookupNS(ctx context.Context, name string) (nslist []*net.NS, err error) <span class="cov8" title="1">{
        var msg *dns.Msg
        if msg, _, err = rc.dnsResolve(ctx, name, dns.TypeNS); err == nil </span><span class="cov8" title="1">{
                for _, rr := range msg.Answer </span><span class="cov8" title="1">{
                        switch rr := rr.(type) </span>{
                        case *dns.NS:<span class="cov8" title="1">
                                nslist = append(nslist, &amp;net.NS{Host: rr.Ns})</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// func (std *Recursive) LookupAddr(ctx context.Context, addr string) ([]string, error)
// func (std *Recursive) LookupMX(ctx context.Context, name string) ([]*net.MX, error)
// func (std *Recursive) LookupPort(ctx context.Context, network, service string) (port int, err error)
// func (std *Recursive) LookupSRV(ctx context.Context, service, proto, name string) (string, []*net.SRV, error)
// func (std *Recursive) LookupTXT(ctx context.Context, name string) ([]string, error)
</pre>
		
		<pre class="file" id="file4" style="display: none">package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "maps"
        "net"
        "net/netip"
        "slices"
        "strings"
        "time"

        "github.com/miekg/dns"
)

const (
        cacheExtra = true // set to false to debug glue lookups
)

type query struct {
        *Recursive
        start  time.Time
        cache  Cacher
        logw   io.Writer
        depth  int
        nomini bool
        sent   int
        steps  int
        glue   map[string][]netip.Addr
        cnames map[string]struct{}
}

func (q *query) dbg() bool <span class="cov8" title="1">{
        return q.logw != nil
}</span>

func (q *query) log(format string, args ...any) bool <span class="cov8" title="1">{
        fmt.Fprintf(q.logw, "[%-5d %2d] %*s", time.Since(q.start).Milliseconds(), q.depth, q.depth, "")
        fmt.Fprintf(q.logw, format, args...)
        return false
}</span>

func maskCookie(s string) string <span class="cov8" title="1">{
        if len(s) &gt; 8 </span><span class="cov8" title="1">{
                return s[:8] + "..."
        }</span>
        <span class="cov8" title="1">return s</span>
}

type hostAddr struct {
        host string
        addr netip.Addr
}

func (ha hostAddr) String() (s string) <span class="cov8" title="1">{
        s = ha.host
        if ha.addr.IsValid() </span><span class="cov8" title="1">{
                s += " " + ha.addr.String()
        }</span>
        <span class="cov8" title="1">return</span>
}

// needGlue returns true if the host was added to the glue map
func (q *query) needGlue(host string) (yes bool) <span class="cov8" title="1">{
        if _, ok := q.glue[host]; !ok </span><span class="cov8" title="1">{
                yes = true
                q.glue[host] = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

// addGlue adds the addr to the glue map for host if it exists and addr is usable
func (q *query) addGlue(host string, addr netip.Addr) <span class="cov8" title="1">{
        if q.useable(addr) </span><span class="cov8" title="1">{
                if addrs, ok := q.glue[host]; ok </span><span class="cov8" title="1">{
                        if !slices.Contains(addrs, addr) </span><span class="cov8" title="1">{
                                q.glue[host] = append(addrs, addr)
                        }</span>
                }
        }
}

func (q *query) setCache(msg *dns.Msg) <span class="cov8" title="1">{
        if msg != nil &amp;&amp; !msg.Zero </span><span class="cov8" title="1">{
                if q.cache != nil &amp;&amp; !q.nomini </span><span class="cov8" title="1">{
                        q.cache.DnsSet(msg)
                }</span>
        }
}

func (q *query) glueTypes() (gt []uint16) <span class="cov8" title="1">{
        if q.useIPv4 </span><span class="cov8" title="1">{
                gt = append(gt, dns.TypeA)
        }</span>
        <span class="cov8" title="1">if q.useIPv6 </span><span class="cov8" title="1">{
                gt = append(gt, dns.TypeAAAA)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (q *query) run(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov8" title="1">{
        if err = q.dive(); err == nil </span><span class="cov8" title="1">{
                defer q.surface()

                var nslist []hostAddr // current set of servers to query
                var final bool        // past the last part of the name
                var idx int           // start of current label
                var qlabel int        // label to query for, starting from the right

                qname = dns.CanonicalName(qname)
                nslist = q.getRootServers()

                for !final </span><span class="cov8" title="1">{
                        qlabel++
                        idx, final = dns.PrevLabel(qname, qlabel)
                        cqname := qname[idx:] // current name to ask for
                        cqtype := dns.TypeNS  // current type to ask for
                        if q.nomini </span><span class="cov0" title="0">{
                                cqname = qname
                                cqtype = qtype
                        }</span>
                        <span class="cov8" title="1">if _, ok := q.glue[qname]; ok </span><span class="cov8" title="1">{
                                cqtype = qtype
                        }</span>

                        <span class="cov8" title="1">if q.dbg() </span><span class="cov8" title="1">{
                                var finaltext string
                                if final </span><span class="cov8" title="1">{
                                        finaltext = " FINAL"
                                }</span>
                                <span class="cov8" title="1">q.log("QUERY%s %s %q from %v\n", finaltext, DnsTypeToString(cqtype), cqname, nslist[:min(4, len(nslist))])</span>
                        }

                        <span class="cov8" title="1">var nsrcode int     // RCODE from last nameserver A query resolving glueless names
                        var gotmsg *dns.Msg // last valid response
                trynextnameserver:
                        for _, ha := range nslist </span><span class="cov8" title="1">{
                                if !ha.addr.IsValid() </span><span class="cov8" title="1">{
                                        if q.needGlue(ha.host) </span><span class="cov8" title="1">{
                                                _ = q.dbg() &amp;&amp; q.log("GLUE lookup for NS %q\n", ha.host)
                                                for _, gluetype := range q.glueTypes() </span><span class="cov8" title="1">{
                                                        var m *dns.Msg
                                                        if m, _, err = q.run(ctx, ha.host, gluetype); err == nil </span><span class="cov8" title="1">{
                                                                nsrcode = m.Rcode
                                                                if m.Rcode == dns.RcodeSuccess </span><span class="cov8" title="1">{
                                                                        for _, rr := range m.Answer </span><span class="cov8" title="1">{
                                                                                if host, addr := rrHostAddr(rr); host == ha.host </span><span class="cov8" title="1">{
                                                                                        ha.addr = addr
                                                                                        q.addGlue(host, addr)
                                                                                }</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                                <span class="cov8" title="1">if q.useable(ha.addr) </span><span class="cov8" title="1">{
                                        if gotmsg, err = q.exchange(ctx, ha.addr, cqname, cqtype); err == nil </span><span class="cov8" title="1">{
                                                switch gotmsg.Rcode </span>{
                                                case dns.RcodeSuccess:<span class="cov8" title="1">
                                                        if gotmsg.Authoritative || (idx &gt; 0 &amp;&amp; (nsrcode == dns.RcodeNameError || len(gotmsg.Answer) &gt; 0)) </span><span class="cov8" title="1">{
                                                                q.setCache(gotmsg)
                                                        }</span>
                                                        <span class="cov8" title="1">newlist := q.extractNS(gotmsg)
                                                        if len(newlist) &gt; 0 </span><span class="cov8" title="1">{
                                                                srv = ha.addr
                                                                msg = gotmsg
                                                                nslist = newlist
                                                        }</span>
                                                case dns.RcodeServerFailure:<span class="cov8" title="1">
                                                        if final </span><span class="cov8" title="1">{
                                                                q.setCache(gotmsg)
                                                                srv = ha.addr
                                                                msg = gotmsg
                                                                return
                                                        }</span>
                                                        <span class="cov8" title="1">msg = nil
                                                        srv = ha.addr
                                                        continue trynextnameserver</span>
                                                case dns.RcodeRefused:<span class="cov0" title="0">
                                                        if !q.nomini </span><span class="cov0" title="0">{
                                                                _ = q.dbg() &amp;&amp; q.log("got REFUSED, retry without QNAME minimization\n")
                                                                q.nomini = true
                                                                msg, srv, err = q.run(ctx, qname, qtype)
                                                                return
                                                        }</span>
                                                        <span class="cov0" title="0">fallthrough</span>
                                                default:<span class="cov8" title="1">
                                                        q.setCache(gotmsg)
                                                        srv = ha.addr
                                                        msg = gotmsg
                                                        return</span>
                                                }
                                                <span class="cov8" title="1">break</span> // next qlabel
                                        }
                                }
                        }

                        // asked all nameservers or got a usable answer
                        <span class="cov8" title="1">if gotmsg == nil </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("no ANSWER for %s %q (%s)\n", DnsTypeToString(qtype), qname, dns.RcodeToString[nsrcode])
                                if msg != nil </span><span class="cov0" title="0">{
                                        if qtype == dns.TypeNS </span><span class="cov0" title="0">{
                                                if len(msg.Answer) == 0 </span><span class="cov0" title="0">{
                                                        if len(msg.Question) &gt; 0 &amp;&amp; msg.Question[0].Name == qname </span><span class="cov0" title="0">{
                                                                msg.Answer, msg.Ns = msg.Ns, msg.Answer
                                                        }</span> else<span class="cov0" title="0"> {
                                                                msg.Rcode = nsrcode
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                if nsrcode != dns.RcodeSuccess </span><span class="cov0" title="0">{
                                                        msg.SetQuestion(qname, qtype)
                                                        msg.Rcode = nsrcode
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        err = errors.Join(err, ErrNoResponse)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if msg == nil </span><span class="cov8" title="1">{
                                        _ = q.dbg() &amp;&amp; q.log("all nameservers returned SERVFAIL\n")
                                        q.setCache(gotmsg)
                                        msg = gotmsg
                                }</span>
                        }
                }

                // ask the final nameserves for the record
                <span class="cov8" title="1">if msg != nil </span><span class="cov8" title="1">{
                        var nsaddrs []netip.Addr
                        for _, ha := range nslist </span><span class="cov8" title="1">{
                                if ha.addr.IsValid() </span><span class="cov8" title="1">{
                                        nsaddrs = append(nsaddrs, ha.addr)
                                }</span> else<span class="cov8" title="1"> {
                                        nsaddrs = append(nsaddrs, q.glue[ha.host]...)
                                }</span>
                        }
                        <span class="cov8" title="1">slices.SortFunc(nsaddrs, func(a, b netip.Addr) int </span><span class="cov8" title="1">{ return a.Compare(b) }</span>)
                        <span class="cov8" title="1">nsaddrs = slices.Compact(nsaddrs)
                        if q.dbg() </span><span class="cov8" title="1">{
                                q.log("final nameservers: %v\n", nsaddrs)
                                if q.depth == 1 </span><span class="cov8" title="1">{
                                        keys := slices.Collect(maps.Keys(q.glue))
                                        slices.Sort(keys)
                                        for _, k := range keys </span><span class="cov8" title="1">{
                                                q.log("glue: %q: %v\n", k, q.glue[k])
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">for _, nsaddr := range nsaddrs </span><span class="cov8" title="1">{
                                var finalmsg *dns.Msg
                                if finalmsg, err = q.exchange(ctx, nsaddr, qname, qtype); err == nil &amp;&amp; finalmsg.Rcode != dns.RcodeServerFailure </span><span class="cov8" title="1">{
                                        msg = finalmsg
                                        q.setCache(msg)
                                        if qtype != dns.TypeCNAME </span><span class="cov8" title="1">{
                                                for _, rr := range msg.Answer </span><span class="cov8" title="1">{
                                                        if cn, ok := rr.(*dns.CNAME); ok </span><span class="cov0" title="0">{
                                                                target := dns.CanonicalName(cn.Target)
                                                                if q.followCNAME(target) </span><span class="cov0" title="0">{
                                                                        _ = q.dbg() &amp;&amp; q.log("CNAME QUERY %q =&gt; %q\n", qname, target)
                                                                        if cnmsg, _, cnerr := q.run(ctx, target, qtype); cnerr == nil </span><span class="cov0" title="0">{
                                                                                _ = q.dbg() &amp;&amp; q.log("CNAME ANSWER %s %q with %v records\n", dns.RcodeToString[cnmsg.Rcode], target, len(cnmsg.Answer))
                                                                                msg = msg.Copy()
                                                                                msg.Zero = true
                                                                                msg.Answer = append(msg.Answer, cnmsg.Answer...)
                                                                                msg.Rcode = cnmsg.Rcode
                                                                                return
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                _ = q.dbg() &amp;&amp; q.log("CNAME ERROR %q: %v\n", target, cnerr)
                                                                        }</span>
                                                                }
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">break</span>
                                } else<span class="cov0" title="0"> {
                                        _ = q.dbg() &amp;&amp; q.log("FAILED @%v %s %q: %v\n", nsaddr, DnsTypeToString(qtype), qname, err)
                                }</span>
                        }
                        <span class="cov8" title="1">if err != nil || len(nsaddrs) == 0 </span><span class="cov0" title="0">{
                                // all final nameservers failed to be queried,
                                // so don't use the last NS message unless usable
                                if msg == nil || qtype != dns.TypeNS || qname != msg.Question[0].Name </span><span class="cov0" title="0">{
                                        msg = nil
                                }</span>
                        }
                }

                <span class="cov8" title="1">if msg == nil </span><span class="cov0" title="0">{
                        // manufacture a SERVFAIL
                        msg = new(dns.Msg)
                        msg.SetQuestion(qname, qtype)
                        msg.Rcode = dns.RcodeServerFailure
                }</span> else<span class="cov8" title="1"> {
                        // we got a message to return, disregard network errors
                        err = nil
                }</span>

                <span class="cov8" title="1">_ = q.dbg() &amp;&amp; q.log("ANSWER %s for %s %q with %d records\n",
                        dns.RcodeToString[msg.Rcode],
                        DnsTypeToString(qtype), qname,
                        len(msg.Answer))</span>
        }
        <span class="cov8" title="1">return</span>
}

func rrHostAddr(rr dns.RR) (host string, addr netip.Addr) <span class="cov8" title="1">{
        switch v := rr.(type) </span>{
        case *dns.A:<span class="cov8" title="1">
                if ip, ok := netip.AddrFromSlice(v.A); ok </span><span class="cov8" title="1">{
                        host = dns.CanonicalName(v.Hdr.Name)
                        addr = ip.Unmap()
                }</span>
        case *dns.AAAA:<span class="cov8" title="1">
                if ip, ok := netip.AddrFromSlice(v.AAAA); ok </span><span class="cov8" title="1">{
                        host = dns.CanonicalName(v.Hdr.Name)
                        addr = ip
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (q *query) extractNS(msg *dns.Msg) (hal []hostAddr) <span class="cov8" title="1">{
        nsmap := map[string]struct{}{}
        for _, rrs := range [][]dns.RR{msg.Answer, msg.Ns} </span><span class="cov8" title="1">{
                for _, rr := range rrs </span><span class="cov8" title="1">{
                        switch rr := rr.(type) </span>{
                        case *dns.NS:<span class="cov8" title="1">
                                host := dns.CanonicalName(rr.Ns)
                                nsmap[host] = struct{}{}</span>
                        }
                        <span class="cov8" title="1">host, addr := rrHostAddr(rr)
                        q.addGlue(host, addr)</span>
                }
        }
        <span class="cov8" title="1">for _, rr := range msg.Extra </span><span class="cov8" title="1">{
                host, addr := rrHostAddr(rr)
                if _, ok := nsmap[host]; ok </span><span class="cov8" title="1">{
                        q.needGlue(host)
                        q.addGlue(host, addr)
                }</span>
        }
        <span class="cov8" title="1">for host := range nsmap </span><span class="cov8" title="1">{
                addrs := q.glue[host]
                if len(addrs) == 0 </span><span class="cov8" title="1">{
                        hal = append(hal, hostAddr{host: host})
                }</span> else<span class="cov8" title="1"> {
                        for _, addr := range addrs </span><span class="cov8" title="1">{
                                hal = append(hal, hostAddr{host: host, addr: addr})
                        }</span>
                }
        }
        // Make the NS query order deterministic.
        <span class="cov8" title="1">slices.SortFunc(hal, func(a, b hostAddr) int </span><span class="cov8" title="1">{
                if a.addr.IsValid() </span><span class="cov8" title="1">{
                        if b.addr.IsValid() </span><span class="cov8" title="1">{
                                return a.addr.Compare(b.addr)
                        }</span>
                        <span class="cov8" title="1">return -1</span>
                }
                <span class="cov8" title="1">if b.addr.IsValid() </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">n := strings.Count(a.host, ".") - strings.Count(b.host, ".")
                if n == 0 </span><span class="cov8" title="1">{
                        n = strings.Compare(a.host, b.host)
                }</span>
                <span class="cov8" title="1">return n</span>
        })
        <span class="cov8" title="1">return</span>
}

func (q *query) dive() (err error) <span class="cov8" title="1">{
        err = ErrMaxDepth
        if q.depth &lt; maxDepth </span><span class="cov8" title="1">{
                q.depth++
                err = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

func (q *query) surface() <span class="cov8" title="1">{
        q.depth--
}</span>

func (q *query) followCNAME(cn string) bool <span class="cov0" title="0">{
        if q.cnames == nil </span><span class="cov0" title="0">{
                q.cnames = make(map[string]struct{})
        }</span>
        <span class="cov0" title="0">_, ok := q.cnames[cn]
        if !ok </span><span class="cov0" title="0">{
                q.cnames[cn] = struct{}{}
        }</span>
        <span class="cov0" title="0">return !ok</span>
}

func (q *query) exchangeUsing(ctx context.Context, protocol string, useCookies bool, nsaddr netip.Addr, qname string, qtype uint16) (msg *dns.Msg, err error) <span class="cov8" title="1">{
        q.steps++
        if q.steps &gt; maxSteps </span><span class="cov8" title="1">{
                err = ErrMaxSteps
                return
        }</span>
        <span class="cov8" title="1">if q.cache != nil &amp;&amp; !q.nomini </span><span class="cov8" title="1">{
                if msg = q.cache.DnsGet(qname, qtype); msg != nil </span><span class="cov8" title="1">{
                        if !cacheExtra </span><span class="cov0" title="0">{
                                msg.Extra = nil
                        }</span>
                        <span class="cov8" title="1">if q.dbg() </span><span class="cov0" title="0">{
                                auth := ""
                                if msg.MsgHdr.Authoritative </span><span class="cov0" title="0">{
                                        auth = " AUTH"
                                }</span>
                                <span class="cov0" title="0">q.log("cached answer: %s %q =&gt; %s [%v+%v+%v A/N/E]%s\n",
                                        DnsTypeToString(qtype), qname,
                                        dns.RcodeToString[msg.Rcode],
                                        len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                        auth,
                                )</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
        }

        <span class="cov8" title="1">if err = q.getUsable(ctx, protocol, nsaddr); err == nil </span><span class="cov8" title="1">{
                var network string
                if nsaddr.Is4() </span><span class="cov8" title="1">{
                        network = protocol + "4"
                }</span> else<span class="cov8" title="1"> {
                        network = protocol + "6"
                }</span>

                <span class="cov8" title="1">if q.rateLimiter != nil </span><span class="cov0" title="0">{
                        &lt;-q.rateLimiter
                }</span>

                <span class="cov8" title="1">if q.dbg() </span><span class="cov8" title="1">{
                        var protostr string
                        var dash6str string
                        if protocol != "udp" </span><span class="cov0" title="0">{
                                protostr = " +" + protocol
                        }</span>
                        <span class="cov8" title="1">if nsaddr.Is6() </span><span class="cov0" title="0">{
                                dash6str = " -6"
                        }</span>
                        <span class="cov8" title="1">q.log("SENDING %s: @%s%s%s %s %q", network, nsaddr, protostr, dash6str, DnsTypeToString(qtype), qname)</span>
                }

                <span class="cov8" title="1">var nconn net.Conn
                var rtt time.Duration

                if q.Timeout &gt; 0 </span><span class="cov8" title="1">{
                        ctx2, cancel := context.WithTimeout(ctx, q.Timeout)
                        defer cancel()
                        ctx = ctx2
                }</span>

                <span class="cov8" title="1">if nconn, err = q.DialContext(ctx, network, netip.AddrPortFrom(nsaddr, dnsPort).String()); err == nil </span><span class="cov8" title="1">{
                        q.sent++
                        dnsconn := &amp;dns.Conn{Conn: nconn, UDPSize: dns.DefaultMsgSize}
                        defer dnsconn.Close()

                        m := new(dns.Msg)
                        m.SetQuestion(qname, qtype)
                        opt := new(dns.OPT)
                        opt.Hdr.Name = "."
                        opt.Hdr.Rrtype = dns.TypeOPT
                        opt.SetUDPSize(dns.DefaultMsgSize)

                        var hasSrvCookie bool
                        var clicookie, srvcookie string

                        if useCookies </span><span class="cov8" title="1">{
                                clicookie = q.clicookie
                                srvcookie, hasSrvCookie = q.getSrvCookie(nsaddr)

                                useCookies = !hasSrvCookie || srvcookie != ""

                                if useCookies </span><span class="cov8" title="1">{
                                        opt.Option = append(opt.Option, &amp;dns.EDNS0_COOKIE{
                                                Code:   dns.EDNS0COOKIE,
                                                Cookie: clicookie + srvcookie,
                                        })
                                        if q.logw != nil </span><span class="cov8" title="1">{
                                                fmt.Fprintf(q.logw, " COOKIE:c=%q s=%q", maskCookie(clicookie), maskCookie(srvcookie))
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">m.Extra = append(m.Extra, opt)
                        c := dns.Client{UDPSize: dns.DefaultMsgSize}
                        msg, rtt, err = c.ExchangeWithConnContext(ctx, m, dnsconn)
                        if useCookies &amp;&amp; msg != nil </span><span class="cov8" title="1">{
                                newsrvcookie := srvcookie
                                if opt := msg.IsEdns0(); opt != nil </span><span class="cov8" title="1">{
                                        for _, rr := range opt.Option </span><span class="cov0" title="0">{
                                                switch rr := rr.(type) </span>{
                                                case *dns.EDNS0_COOKIE:<span class="cov0" title="0">
                                                        if strings.HasPrefix(rr.Cookie, clicookie) </span><span class="cov0" title="0">{
                                                                newsrvcookie = strings.TrimPrefix(rr.Cookie, clicookie)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                msg = nil
                                                                err = ErrInvalidCookie
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">if !hasSrvCookie || srvcookie != newsrvcookie </span><span class="cov8" title="1">{
                                        q.setSrvCookie(nsaddr, newsrvcookie)
                                }</span>
                        }
                }

                <span class="cov8" title="1">isIpv6Err, isUdpErr := q.setNetError(protocol, nsaddr, err)
                ipv6disabled := isIpv6Err &amp;&amp; q.maybeDisableIPv6(err)
                udpDisabled := isUdpErr &amp;&amp; q.maybeDisableUdp(err)

                if q.logw != nil </span><span class="cov8" title="1">{
                        if msg != nil </span><span class="cov8" title="1">{
                                fmt.Fprintf(q.logw, " =&gt; %s [%v+%v+%v A/N/E] (%v, %d bytes",
                                        dns.RcodeToString[msg.Rcode],
                                        len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                        rtt.Round(time.Millisecond), msg.Len())
                                if msg.MsgHdr.Truncated </span><span class="cov0" title="0">{
                                        fmt.Fprintf(q.logw, " TRNC")
                                }</span>
                                <span class="cov8" title="1">if msg.MsgHdr.Authoritative </span><span class="cov8" title="1">{
                                        fmt.Fprintf(q.logw, " AUTH")
                                }</span>
                                <span class="cov8" title="1">if opt := msg.IsEdns0(); opt != nil </span><span class="cov0" title="0">{
                                        if er := uint16(opt.ExtendedRcode()); /*#nosec G115*/ er != 0 </span><span class="cov0" title="0">{
                                                fmt.Fprintf(q.logw, " EDNS=%s", dns.ExtendedErrorCodeToString[er])
                                        }</span>
                                }
                                <span class="cov8" title="1">fmt.Fprintf(q.logw, ")")</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " error: %v", err)
                        }</span>
                        <span class="cov8" title="1">if ipv6disabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (IPv6 disabled)")
                        }</span>
                        <span class="cov8" title="1">if udpDisabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (UDP disabled)")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintln(q.logw)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (q *query) exchange(ctx context.Context, nsaddr netip.Addr, qname string, qtype uint16) (msg *dns.Msg, err error) <span class="cov8" title="1">{
        useCookies := true
        if q.usingUDP() </span><span class="cov8" title="1">{
                msg, err = q.exchangeUsing(ctx, "udp", useCookies, nsaddr, qname, qtype)
                if msg != nil </span><span class="cov8" title="1">{
                        if msg.MsgHdr.Truncated </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("message truncated; retry using TCP\n")
                                msg = nil
                        }</span> else<span class="cov8" title="1"> if msg.MsgHdr.Rcode == dns.RcodeFormatError </span><span class="cov0" title="0">{
                                _ = q.dbg() &amp;&amp; q.log("got FORMERR, retry using TCP without cookies\n")
                                msg = nil
                                useCookies = false
                        }</span>
                }
        }
        <span class="cov8" title="1">if (msg == nil || err != nil) &amp;&amp; q.useable(nsaddr) </span><span class="cov8" title="1">{
                msg, err = q.exchangeUsing(ctx, "tcp", useCookies, nsaddr, qname, qtype)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package recursive

import (
        "context"
        crand "crypto/rand"
        "errors"
        "fmt"
        "io"
        rand "math/rand/v2"
        "net"
        "net/netip"
        "os"
        "sort"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/miekg/dns"
        "golang.org/x/net/proxy"
)

//go:generate go run ./cmd/genhints roothints.gen.go

const (
        maxDepth = 32   // maximum recursion depth
        maxSteps = 1000 // max number of steps to allow in resolving
)

var (
        // ErrInvalidCookie is returned if the DNS cookie from the server is invalid.
        ErrInvalidCookie = errors.New("invalid cookie")
        // ErrMaxDepth is returned when recursive resolving exceeds the allowed limit.
        ErrMaxDepth = fmt.Errorf("recursion depth exceeded %d", maxDepth)
        // ErrMaxSteps is returned when resolving exceeds the step limit.
        ErrMaxSteps = fmt.Errorf("resolve steps exceeded %d", maxSteps)
        // ErrNoResponse is returned when no authoritative server could be successfully queried.
        // It is equivalent to SERVFAIL.
        ErrNoResponse = errors.New("no authoritative response")
        // ErrQuestionMismatch is returned when the DNS response is not for what was queried.
        ErrQuestionMismatch = errors.New("question mismatch")
        DefaultCache        = NewCache()
        DefaultTimeout      = time.Second * 5
)

var _ Resolver = (*Recursive)(nil) // ensure we implement interface

const (
        maxSrvCookies = 8192
        srvCookieTTL  = 24 * time.Hour
)

type srvCookie struct {
        value string
        ts    time.Time
}

type Recursive struct {
        proxy.ContextDialer                 // (read-only) ContextDialer passed to NewWithOptions
        Cacher                              // (read-only) Cacher passed to NewWithOptions
        *net.Resolver                       // (read-only) net.Resolver using our ContextDialer
        Timeout             time.Duration   // (read-only) dialing timeout, zero to disable
        rateLimiter         &lt;-chan struct{} // (read-only) rate limited passed to NewWithOptions
        DefaultLogWriter    io.Writer       // if not nil, write debug logs here unless overridden
        mu                  sync.RWMutex    // protects following
        useUDP              bool
        useIPv4             bool
        useIPv6             bool
        rootServers         []netip.Addr
        clicookie           string
        srvcookies          map[netip.Addr]srvCookie
        udperrs             map[netip.Addr]netError
        tcperrs             map[netip.Addr]netError
        dnsResolve          func(context.Context, string, uint16) (*dns.Msg, netip.Addr, error)
}

func makeCookie() string <span class="cov8" title="1">{
        b := make([]byte, 8)
        if _, err := crand.Read(b); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%x", b)</span>
}

func shuffleAddrs(a []netip.Addr) <span class="cov8" title="1">{
        rand.Shuffle(len(a), func(i, j int) </span><span class="cov8" title="1">{
                a[i], a[j] = a[j], a[i]
        }</span>)
}

// NewWithOptions returns a new Recursive resolver using the given ContextDialer and
// using the given Cacher as it's default cache. It does not call OrderRoots.
//
// Passing nil for dialer will use a net.Dialer.
// Passing nil for cache means it won't use any cache by default.
// Passing nil for the roots will use the default set of roots.
// Passing nil for the rateLimiter means no rate limiting
func NewWithOptions(dialer proxy.ContextDialer, cache Cacher, roots4, roots6 []netip.Addr, rateLimiter &lt;-chan struct{}) *Recursive <span class="cov8" title="1">{
        if dialer == nil </span><span class="cov8" title="1">{
                dialer = &amp;net.Dialer{}
        }</span>
        <span class="cov8" title="1">if roots4 == nil </span><span class="cov8" title="1">{
                roots4 = Roots4
        }</span>
        <span class="cov8" title="1">if roots6 == nil </span><span class="cov8" title="1">{
                roots6 = Roots6
        }</span>

        <span class="cov8" title="1">var root4, root6 []netip.Addr
        if len(roots4) &gt; 0 </span><span class="cov8" title="1">{
                root4 = append(root4, roots4...)
                shuffleAddrs(root4)
        }</span>
        <span class="cov8" title="1">if len(roots6) &gt; 0 </span><span class="cov8" title="1">{
                root6 = append(root6, roots6...)
                shuffleAddrs(root6)
        }</span>

        <span class="cov8" title="1">roots := make([]netip.Addr, 0, len(root4)+len(root6))
        n := min(len(root4), len(root6))
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                roots = append(roots, root4[i], root6[i])
        }</span>
        <span class="cov8" title="1">roots = append(roots, root4[n:]...)
        roots = append(roots, root6[n:]...)

        r := &amp;Recursive{
                ContextDialer: dialer,
                Cacher:        cache,
                Resolver: &amp;net.Resolver{
                        PreferGo: true,
                        Dial:     dialer.DialContext,
                },
                Timeout:     DefaultTimeout,
                rateLimiter: rateLimiter,
                useUDP:      true,
                useIPv4:     len(root4) &gt; 0,
                useIPv6:     len(root6) &gt; 0,
                rootServers: roots,
                clicookie:   makeCookie(),
                srvcookies:  make(map[netip.Addr]srvCookie),
                udperrs:     make(map[netip.Addr]netError),
                tcperrs:     make(map[netip.Addr]netError),
        }
        r.dnsResolve = r.DnsResolve
        return r</span>
}

// New returns a new Recursive resolver using the given ContextDialer and
// has DefaultCache as it's cache.
//
// It calls OrderRoots before returning.
func New(dialer proxy.ContextDialer) *Recursive <span class="cov8" title="1">{
        r := NewWithOptions(dialer, DefaultCache, nil, nil, nil)
        r.OrderRoots(context.Background())
        return r
}</span>

// ResetCookies generates a new DNS client cookie and clears the known DNS server cookies.
func (r *Recursive) ResetCookies() <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.clicookie = makeCookie()
        clear(r.srvcookies)
}</span>

func (r *Recursive) cleanupSrvCookiesLocked(now time.Time) <span class="cov8" title="1">{
        cutoff := now.Add(-srvCookieTTL)
        for addr, c := range r.srvcookies </span><span class="cov8" title="1">{
                if c.ts.Before(cutoff) </span><span class="cov8" title="1">{
                        delete(r.srvcookies, addr)
                }</span>
        }
        <span class="cov8" title="1">if len(r.srvcookies) &lt;= maxSrvCookies </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">type ac struct {
                addr netip.Addr
                ts   time.Time
        }
        l := make([]ac, 0, len(r.srvcookies))
        for addr, c := range r.srvcookies </span><span class="cov8" title="1">{
                l = append(l, ac{addr: addr, ts: c.ts})
        }</span>
        <span class="cov8" title="1">sort.Slice(l, func(i, j int) bool </span><span class="cov8" title="1">{ return l[i].ts.Before(l[j].ts) }</span>)
        <span class="cov8" title="1">for i := 0; len(r.srvcookies) &gt; maxSrvCookies &amp;&amp; i &lt; len(l); i++ </span><span class="cov8" title="1">{
                delete(r.srvcookies, l[i].addr)
        }</span>
}

func (r *Recursive) cleanupSrvCookies(now time.Time) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cleanupSrvCookiesLocked(now)
}</span>

func (r *Recursive) getSrvCookie(addr netip.Addr) (string, bool) <span class="cov8" title="1">{
        now := time.Now()
        r.cleanupSrvCookies(now)
        r.mu.RLock()
        c, ok := r.srvcookies[addr]
        r.mu.RUnlock()
        if ok &amp;&amp; now.Sub(c.ts) &lt; srvCookieTTL </span><span class="cov8" title="1">{
                return c.value, true
        }</span>
        <span class="cov8" title="1">return "", false</span>
}

func (r *Recursive) setSrvCookie(addr netip.Addr, val string) <span class="cov8" title="1">{
        now := time.Now()
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cleanupSrvCookiesLocked(now)
        r.srvcookies[addr] = srvCookie{value: val, ts: now}
}</span>

// OrderRoots sorts the root server list by their current latency and removes those that don't respond.
//
// If ctx does not have a deadline, DefaultTimeout will be used.
func (r *Recursive) OrderRoots(ctx context.Context) <span class="cov8" title="1">{
        if _, ok := ctx.Deadline(); !ok </span><span class="cov8" title="1">{
                newctx, cancel := context.WithTimeout(ctx, DefaultTimeout)
                defer cancel()
                ctx = newctx
        }</span>
        <span class="cov8" title="1">r.mu.Lock()
        defer r.mu.Unlock()
        var l []*rootRtt
        var wg sync.WaitGroup
        for _, addr := range r.rootServers </span><span class="cov8" title="1">{
                rt := &amp;rootRtt{addr: addr}
                l = append(l, rt)
                wg.Add(1)
                go timeRoot(ctx, r, &amp;wg, rt)
        }</span>
        <span class="cov8" title="1">wg.Wait()
        sort.Slice(l, func(i, j int) bool </span><span class="cov8" title="1">{ return l[i].rtt &lt; l[j].rtt }</span>)
        <span class="cov8" title="1">var newRootServers []netip.Addr
        useIPv4 := false
        useIPv6 := false
        for _, rt := range l </span><span class="cov8" title="1">{
                if rt.rtt &lt; time.Minute </span><span class="cov8" title="1">{
                        useIPv4 = useIPv4 || rt.addr.Is4()
                        useIPv6 = useIPv6 || rt.addr.Is6()
                        newRootServers = append(newRootServers, rt.addr)
                }</span>
        }
        <span class="cov8" title="1">if len(newRootServers) &gt; 0 </span><span class="cov8" title="1">{
                r.rootServers = newRootServers
                r.useIPv4 = useIPv4
                r.useIPv6 = useIPv6
        }</span>
}

// ResolveWithOptions performs a recursive DNS resolution for the provided name and record type.
//
// If cache is nil, no cache is used; nil caches are supported without crashing.
// If logw is non-nil (or DefaultLogWriter is set), write a log of events.
func (r *Recursive) ResolveWithOptions(ctx context.Context, cache Cacher, logw io.Writer, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov8" title="1">{
        if logw == nil </span><span class="cov8" title="1">{
                logw = r.DefaultLogWriter
        }</span>
        <span class="cov8" title="1">r.cleanupSrvCookies(time.Now())
        var q *query
        qname = dns.CanonicalName(qname)
        if cache != nil </span><span class="cov8" title="1">{
                msg = cache.DnsGet(qname, qtype)
        }</span>
        <span class="cov8" title="1">if msg == nil </span><span class="cov8" title="1">{
                q = &amp;query{
                        Recursive: r,
                        cache:     cache,
                        start:     time.Now(),
                        logw:      logw,
                        glue:      make(map[string][]netip.Addr),
                }
                msg, srv, err = q.run(ctx, qname, qtype)
        }</span>
        <span class="cov8" title="1">if msg != nil </span><span class="cov8" title="1">{
                if msg.Rcode == dns.RcodeSuccess </span><span class="cov8" title="1">{
                        // A SUCCESS reply must reference the correct QNAME and QTYPE.
                        var gotname string
                        var gottype uint16
                        if len(msg.Question) &gt; 0 </span><span class="cov8" title="1">{
                                gotname = msg.Question[0].Name
                                gottype = msg.Question[0].Qtype
                        }</span>
                        <span class="cov8" title="1">if gotname != qname || gottype != qtype </span><span class="cov8" title="1">{
                                err = ErrQuestionMismatch
                                _ = q.dbg() &amp;&amp; q.log("ERROR: ANSWER was for %s %q, not %s %q\n",
                                        DnsTypeToString(gottype), gotname,
                                        DnsTypeToString(qtype), qname,
                                )
                        }</span>
                } else<span class="cov0" title="0"> {
                        if !msg.Zero </span><span class="cov0" title="0">{
                                // NXDOMAIN or other failures may have the returned
                                // question refer to some NS in the chain, but we still want
                                // to associate the reply with the original query.
                                msg.SetQuestion(qname, qtype)
                        }</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        if cache != nil </span><span class="cov8" title="1">{
                                cache.DnsSet(msg)
                        }</span>
                }
        }
        <span class="cov8" title="1">if logw != nil </span><span class="cov8" title="1">{
                if msg != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(logw, "\n%v", msg)
                }</span>
                <span class="cov8" title="1">if q != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(logw, "\n;; Sent %v queries in %v", q.sent, time.Since(q.start).Round(time.Millisecond))
                }</span>
                <span class="cov8" title="1">if srv.IsValid() </span><span class="cov8" title="1">{
                        fmt.Fprintf(logw, "\n;; SERVER: %v", srv)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(logw, "\n;; ERROR: %v", err)
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(logw)</span>
        }
        <span class="cov8" title="1">return</span>
}

// DnsResolve performs a recursive DNS resolution for the provided name and record type.
func (r *Recursive) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov8" title="1">{
        return r.ResolveWithOptions(ctx, r, nil, qname, qtype)
}</span>

func (r *Recursive) getRootServers() (nslist []hostAddr) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov8" title="1">{
                nslist = append(nslist, hostAddr{"root", addr})
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetRoots returns the current set of root servers in use.
func (r *Recursive) GetRoots() (root4, root6 []netip.Addr) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov8" title="1">{
                if addr.Is4() </span><span class="cov8" title="1">{
                        root4 = append(root4, addr)
                }</span>
                <span class="cov8" title="1">if addr.Is6() </span><span class="cov8" title="1">{
                        root6 = append(root6, addr)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (r *Recursive) usingUDP() (yes bool) <span class="cov8" title="1">{
        r.mu.RLock()
        yes = r.useUDP
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) useable(addr netip.Addr) (ok bool) <span class="cov8" title="1">{
        if addr.IsValid() </span><span class="cov8" title="1">{
                r.mu.RLock()
                ok = (r.useIPv4 &amp;&amp; addr.Is4()) || (r.useIPv6 &amp;&amp; addr.Is6())
                r.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (r *Recursive) setNetError(protocol string, nsaddr netip.Addr, err error) (isIpv6err, isUdpErr bool) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                isIpv6err = nsaddr.Is6()
                var ne net.Error
                ok := errors.Is(err, io.EOF)
                if errors.As(err, &amp;ne) </span><span class="cov8" title="1">{
                        ok = true
                }</span>
                <span class="cov8" title="1">ok = ok || errors.Is(err, os.ErrDeadlineExceeded) || errors.Is(err, context.DeadlineExceeded)
                ok = ok || errors.Is(err, syscall.ECONNREFUSED)
                errstr := err.Error()
                ok = ok || strings.Contains(errstr, "timeout") || strings.Contains(errstr, "refused")
                if ok </span><span class="cov8" title="1">{
                        var m map[netip.Addr]netError
                        switch protocol </span>{
                        case "udp":<span class="cov8" title="1">
                                isUdpErr = true
                                m = r.udperrs</span>
                        case "tcp":<span class="cov8" title="1">
                                m = r.tcperrs</span>
                        }
                        <span class="cov8" title="1">if m != nil </span><span class="cov8" title="1">{
                                r.mu.Lock()
                                m[nsaddr] = netError{Err: err, When: time.Now()}
                                r.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (r *Recursive) getUsable(ctx context.Context, protocol string, nsaddr netip.Addr) (err error) <span class="cov8" title="1">{
        if err = ctx.Err(); err == nil </span><span class="cov8" title="1">{
                var m map[netip.Addr]netError
                switch protocol </span>{
                case "udp", "udp4", "udp6":<span class="cov8" title="1">
                        m = r.udperrs</span>
                case "tcp", "tcp4", "tcp6":<span class="cov8" title="1">
                        m = r.tcperrs</span>
                }
                <span class="cov8" title="1">err = net.ErrClosed
                if m != nil </span><span class="cov8" title="1">{
                        r.mu.RLock()
                        ne, hasNetError := m[nsaddr]
                        if !hasNetError </span><span class="cov8" title="1">{
                                if (r.useIPv4 &amp;&amp; nsaddr.Is4()) || (r.useIPv6 &amp;&amp; nsaddr.Is6()) </span><span class="cov8" title="1">{
                                        err = nil
                                }</span>
                        }
                        <span class="cov8" title="1">r.mu.RUnlock()
                        if hasNetError </span><span class="cov0" title="0">{
                                err = ne
                                if time.Since(ne.When) &gt; time.Minute </span><span class="cov0" title="0">{
                                        err = nil
                                        r.mu.Lock()
                                        delete(m, nsaddr)
                                        r.mu.Unlock()
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (r *Recursive) maybeDisableIPv6(err error) (disabled bool) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                errstr := err.Error()
                if errors.Is(err, syscall.ENETUNREACH) || errors.Is(err, syscall.EHOSTUNREACH) ||
                        strings.Contains(errstr, "network is unreachable") || strings.Contains(errstr, "no route to host") </span><span class="cov8" title="1">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        if r.useIPv6 </span><span class="cov8" title="1">{
                                disabled = true
                                r.useIPv6 = false
                                var idx int
                                for i := range r.rootServers </span><span class="cov8" title="1">{
                                        if r.rootServers[i].Is4() </span><span class="cov8" title="1">{
                                                r.rootServers[idx] = r.rootServers[i]
                                                idx++
                                        }</span>
                                }
                                <span class="cov8" title="1">r.rootServers = r.rootServers[:idx]</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (r *Recursive) maybeDisableUdp(err error) (disabled bool) <span class="cov8" title="1">{
        var ne net.Error
        if errors.As(err, &amp;ne) &amp;&amp; !ne.Timeout() </span><span class="cov8" title="1">{
                errstr := err.Error()
                if errors.Is(err, syscall.ENOSYS) || errors.Is(err, syscall.EPROTONOSUPPORT) || strings.Contains(errstr, "network not implemented") </span><span class="cov8" title="1">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        disabled = r.useUDP
                        r.useUDP = false
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sync"
        "time"

        "golang.org/x/net/proxy"
)

type rootRtt struct {
        addr netip.Addr
        rtt  time.Duration
}

func timeRoot(ctx context.Context, dialer proxy.ContextDialer, wg *sync.WaitGroup, rt *rootRtt) <span class="cov8" title="1">{
        defer wg.Done()
        const numProbes = 3
        network := "tcp4"
        if rt.addr.Is6() </span><span class="cov8" title="1">{
                network = "tcp6"
        }</span>
        <span class="cov8" title="1">rt.rtt = time.Hour
        var rtt time.Duration
        for i := 0; i &lt; numProbes; i++ </span><span class="cov8" title="1">{
                now := time.Now()
                conn, err := dialer.DialContext(ctx, network, netip.AddrPortFrom(rt.addr, dnsPort).String())
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">rtt += time.Since(now)
                _ = conn.Close()</span>
        }
        <span class="cov8" title="1">rt.rtt = rtt / numProbes</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package recursive

import (
        "math"
        "net/netip"
        "strconv"

        "github.com/miekg/dns"
)

func DnsTypeToString(qtype uint16) string <span class="cov8" title="1">{
        if s, ok := dns.TypeToString[qtype]; ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return strconv.Itoa(int(qtype))</span>
}

func AddrFromRR(rr dns.RR) netip.Addr <span class="cov8" title="1">{
        switch v := rr.(type) </span>{
        case *dns.A:<span class="cov8" title="1">
                if ip, ok := netip.AddrFromSlice(v.A); ok </span><span class="cov8" title="1">{
                        return ip.Unmap()
                }</span>
        case *dns.AAAA:<span class="cov8" title="1">
                if ip, ok := netip.AddrFromSlice(v.AAAA); ok </span><span class="cov8" title="1">{
                        return ip
                }</span>
        }
        <span class="cov8" title="1">return netip.Addr{}</span>
}

// MinTTL returns the lowest resource record TTL in the message, or -1 if there are no records.
func MinTTL(msg *dns.Msg) int <span class="cov8" title="1">{
        minTTL := math.MaxInt
        for _, rr := range msg.Answer </span><span class="cov8" title="1">{
                minTTL = min(minTTL, int(rr.Header().Ttl))
        }</span>
        <span class="cov8" title="1">for _, rr := range msg.Ns </span><span class="cov8" title="1">{
                minTTL = min(minTTL, int(rr.Header().Ttl))
        }</span>
        <span class="cov8" title="1">for _, rr := range msg.Extra </span><span class="cov8" title="1">{
                if rr.Header().Rrtype != dns.TypeOPT </span><span class="cov8" title="1">{
                        minTTL = min(minTTL, int(rr.Header().Ttl))
                }</span>
        }
        <span class="cov8" title="1">if minTTL == math.MaxInt </span><span class="cov8" title="1">{
                minTTL = -1
        }</span>
        <span class="cov8" title="1">return minTTL</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
