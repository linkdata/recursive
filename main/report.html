
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>recursive: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/recursive/cache.go (98.7%)</option>
				
				<option value="file1">github.com/linkdata/recursive/cachebucket.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/recursive/cachemarshalling.go (93.2%)</option>
				
				<option value="file3">github.com/linkdata/recursive/cachevalue.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/recursive/cookie.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/recursive/disable.go (100.0%)</option>
				
				<option value="file6">github.com/linkdata/recursive/extendedrcode.go (100.0%)</option>
				
				<option value="file7">github.com/linkdata/recursive/ioutil.go (100.0%)</option>
				
				<option value="file8">github.com/linkdata/recursive/neterror.go (100.0%)</option>
				
				<option value="file9">github.com/linkdata/recursive/orderroots.go (100.0%)</option>
				
				<option value="file10">github.com/linkdata/recursive/query.go (82.5%)</option>
				
				<option value="file11">github.com/linkdata/recursive/recursive.go (100.0%)</option>
				
				<option value="file12">github.com/linkdata/recursive/timeroot.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package recursive

import (
        "context"
        "math"
        "net/netip"
        "sync/atomic"
        "time"

        "github.com/miekg/dns"
)

const DefaultMinTTL = 10
const DefaultMaxTTL = 7 * 24 * 60 * 60
const DefaultNXTTL = 60 * 60
const cacheBucketCountBits = 5
const cacheBucketCount = (1 &lt;&lt; cacheBucketCountBits)

type Cache struct {
        MinTTL int64 // always cache responses for at least this long seconds
        MaxTTL int64 // never cache responses for longer than this seconds (excepting successful NS responses)
        NXTTL  int64 // cache NXDOMAIN responses for this long seconds
        count  atomic.Uint64
        hits   atomic.Uint64
        cq     [cacheBucketCount]*cacheBucket
}

var _ CachingResolver = &amp;Cache{}

func NewCache() *Cache <span class="cov3" title="32">{
        cache := &amp;Cache{
                MinTTL: DefaultMinTTL,
                MaxTTL: DefaultMaxTTL,
                NXTTL:  DefaultNXTTL,
        }
        for i := range cache.cq </span><span class="cov5" title="1024">{
                cache.cq[i] = newCacheBucket()
        }</span>
        <span class="cov3" title="32">return cache</span>
}

// HitRatio returns the hit ratio as a percentage.
func (cache *Cache) HitRatio() (n float64) <span class="cov1" title="3">{
        if cache != nil </span><span class="cov1" title="3">{
                if count := cache.count.Load(); count &gt; 0 </span><span class="cov1" title="3">{
                        n = float64(cache.hits.Load()*100) / float64(count)
                }</span>
        }
        <span class="cov1" title="3">return</span>
}

// Entries returns the number of entries in the cache.
func (cache *Cache) Entries() (n int) <span class="cov2" title="19">{
        if cache != nil </span><span class="cov2" title="19">{
                for _, cq := range cache.cq </span><span class="cov4" title="608">{
                        n += cq.entries()
                }</span>
        }
        <span class="cov2" title="19">return</span>
}

func newBucketKey(qname string, qtype uint16) (key bucketKey) <span class="cov10" title="5001268">{
        key = bucketKey{qname: qname, qtype: qtype}
        return
}</span>

func (cache *Cache) bucketFor(key bucketKey) (bucket *cacheBucket) <span class="cov9" title="2000651">{
        bucket = cache.cq[bucketIndexForQname(key.qname)]
        return
}</span>

// DnsSet add a DNS message to the cache.
//
// Does nothing if the message has the Zero flag set, or does not have exactly one Question.
func (cache *Cache) DnsSet(msg *dns.Msg) <span class="cov9" title="2000358">{
        if cache != nil &amp;&amp; msg != nil &amp;&amp; !msg.Zero &amp;&amp; len(msg.Question) == 1 </span><span class="cov9" title="2000358">{
                question := msg.Question[0]
                key := newBucketKey(question.Name, question.Qtype)
                msg = msg.Copy()
                msg.Zero = true
                ttl := cache.NXTTL
                if msg.Rcode != dns.RcodeNameError </span><span class="cov9" title="2000352">{
                        ttl = max(cache.MinTTL, minDNSMsgTTL(msg))
                        if question.Qtype != dns.TypeNS || msg.Rcode != dns.RcodeSuccess </span><span class="cov9" title="1933609">{
                                ttl = min(cache.MaxTTL, ttl)
                        }</span>
                }
                <span class="cov9" title="2000358">cache.bucketFor(key).set(msg, time.Now().Unix()+ttl)</span>
        }
}

// DnsGet returns a caches DNS message if one exists that has not expired.
//
// If an expired message is found, it is removed from the cache and nil is returned.
func (cache *Cache) DnsGet(qname string, qtype uint16) (msg *dns.Msg) <span class="cov4" title="274">{
        msg, _ = cache.Get(qname, qtype, false)
        return
}</span>

// Get allows getting stale DNS entries from the cache if allowstale is true.
func (cache *Cache) Get(qname string, qtype uint16, allowstale bool) (msg *dns.Msg, stale bool) <span class="cov4" title="274">{
        if cache != nil </span><span class="cov4" title="274">{
                cache.count.Add(1)
                key := newBucketKey(qname, qtype)
                if msg, stale = cache.bucketFor(key).get(key, allowstale); msg != nil </span><span class="cov4" title="173">{
                        cache.hits.Add(1)
                }</span>
        }
        <span class="cov4" title="274">return</span>
}

func (cache *Cache) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov1" title="1">{
        msg = cache.DnsGet(qname, qtype)
        return
}</span>

func (cache *Cache) Clear() <span class="cov2" title="11">{
        if cache != nil </span><span class="cov2" title="11">{
                for _, cq := range cache.cq </span><span class="cov4" title="352">{
                        cq.clear()
                }</span>
        }
}

// CleanBefore removes entries that expired before t from the cache.
func (cache *Cache) CleanBefore(t time.Time) <span class="cov1" title="1">{
        if cache != nil &amp;&amp; !t.IsZero() </span><span class="cov1" title="1">{
                for _, cq := range cache.cq </span><span class="cov3" title="32">{
                        cq.clean(t)
                }</span>
        }
}

// Clean removes stale entries from the cache.
func (cache *Cache) Clean() <span class="cov1" title="1">{
        cache.CleanBefore(time.Now())
}</span>

// Merge inserts all entries from other into cache.
// If an entry exists in both, the one that expires last wins.
func (cache *Cache) Merge(other *Cache) <span class="cov1" title="2">{
        if cache != nil &amp;&amp; other != nil &amp;&amp; cache != other </span><span class="cov1" title="2">{
                for i := range other.cq </span><span class="cov3" title="64">{
                        other.cq[i].mu.RLock()
                        cache.cq[i].mu.Lock()
                        for key, cv := range other.cq[i].cache </span><span class="cov1" title="2">{
                                if oldcv, ok := cache.cq[i].cache[key]; !ok || cv.expires &gt; oldcv.expires </span><span class="cov1" title="2">{
                                        cache.cq[i].cache[key] = cv
                                }</span>
                        }
                        <span class="cov3" title="64">cache.cq[i].mu.Unlock()
                        other.cq[i].mu.RUnlock()</span>
                }
        }
}

// Walk calls fn for each entry in the cache. If fn returns an error, it stops and returns that error.
func (cache *Cache) Walk(fn func(msg *dns.Msg, expires time.Time) (err error)) (err error) <span class="cov1" title="2">{
        if cache != nil &amp;&amp; fn != nil </span><span class="cov1" title="2">{
                for _, qc := range cache.cq </span><span class="cov3" title="35">{
                        var cvs []cacheValue
                        qc.mu.RLock()
                        for _, cv := range qc.cache </span><span class="cov1" title="3">{
                                cvs = append(cvs, cv)
                        }</span>
                        <span class="cov3" title="35">qc.mu.RUnlock()
                        for _, cv := range cvs </span><span class="cov1" title="3">{
                                if err = fn(cv.Msg, cv.expiresAt()); err != nil </span><span class="cov1" title="1">{
                                        return
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func minDNSMsgTTL(msg *dns.Msg) (minTTL int64) <span class="cov9" title="2000352">{
        minTTL = math.MaxInt64
        if msg != nil </span><span class="cov9" title="2000352">{
                for _, rr := range msg.Answer </span><span class="cov9" title="2000304">{
                        if rr != nil </span><span class="cov9" title="2000304">{
                                minTTL = min(minTTL, int64(rr.Header().Ttl))
                        }</span>
                }
                <span class="cov9" title="2000352">for _, rr := range msg.Ns </span><span class="cov4" title="329">{
                        if rr != nil </span><span class="cov4" title="329">{
                                minTTL = min(minTTL, int64(rr.Header().Ttl))
                        }</span>
                }
                <span class="cov9" title="2000352">for _, rr := range msg.Extra </span><span class="cov4" title="509">{
                        if rr != nil </span><span class="cov4" title="509">{
                                if rr.Header().Rrtype != dns.TypeOPT </span><span class="cov4" title="416">{
                                        minTTL = min(minTTL, int64(rr.Header().Ttl))
                                }</span>
                        }
                }
        }
        <span class="cov9" title="2000352">if minTTL == math.MaxInt </span><span class="cov0" title="0">{
                minTTL = -1
        }</span>
        <span class="cov9" title="2000352">return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package recursive

import (
        "hash/maphash"
        "sync"
        "time"

        "github.com/miekg/dns"
)

type bucketKey struct {
        qname string
        qtype uint16
}

type cacheBucket struct {
        mu    sync.RWMutex
        cache map[bucketKey]cacheValue
}

func newCacheBucket() *cacheBucket <span class="cov5" title="1024">{
        return &amp;cacheBucket{cache: make(map[bucketKey]cacheValue)}
}</span>

var bucketSeed = maphash.MakeSeed()

func bucketIndexForQname(qname string) (idx int) <span class="cov10" title="3000911">{
        idx = int(maphash.String(bucketSeed, qname) &amp; (cacheBucketCount - 1)) // #nosec G115
        return
}</span>

func (cq *cacheBucket) entries() (n int) <span class="cov4" title="608">{
        cq.mu.RLock()
        n = len(cq.cache)
        cq.mu.RUnlock()
        return
}</span>

func questionBucketKey(q dns.Question) bucketKey <span class="cov9" title="3000620">{
        return newBucketKey(q.Name, q.Qtype)
}</span>

func (cq *cacheBucket) setLocked(msg *dns.Msg, expires int64) <span class="cov9" title="3000620">{
        cq.cache[questionBucketKey(msg.Question[0])] = cacheValue{Msg: msg, expires: expires}
}</span>

func (cq *cacheBucket) set(msg *dns.Msg, expires int64) <span class="cov9" title="2000360">{
        cq.mu.Lock()
        cq.setLocked(msg, expires)
        cq.mu.Unlock()
}</span>

func (cq *cacheBucket) get(key bucketKey, allowstale bool) (msg *dns.Msg, stale bool) <span class="cov4" title="274">{
        cq.mu.RLock()
        cv := cq.cache[key]
        cq.mu.RUnlock()
        if cv.Msg != nil </span><span class="cov4" title="174">{
                expires := cv.expiresAt()
                stale = time.Since(expires) &gt; 0
                if !stale || allowstale </span><span class="cov4" title="173">{
                        msg = cv.Msg
                }</span> else<span class="cov1" title="1"> {
                        cq.mu.Lock()
                        delete(cq.cache, key)
                        cq.mu.Unlock()
                }</span>
        }
        <span class="cov4" title="274">return</span>
}

func (cq *cacheBucket) clear() <span class="cov4" title="352">{
        cq.clean(time.Time{})
}</span>

func (cq *cacheBucket) cleanLocked(t time.Time) <span class="cov4" title="384">{
        for key, cv := range cq.cache </span><span class="cov1" title="2">{
                if t.IsZero() || cv.expiresAt().Before(t) </span><span class="cov1" title="2">{
                        delete(cq.cache, key)
                }</span>
        }
}

func (cq *cacheBucket) clean(t time.Time) <span class="cov4" title="384">{
        cq.mu.Lock()
        defer cq.mu.Unlock()
        cq.cleanLocked(t)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package recursive

import (
        "encoding/binary"
        "errors"
        "io"
        "sync"
)

var ErrWrongMagic = errors.New("wrong magic number")

const cacheMagic = int64(0xCACE0003)
const marshalWorkerBufferSize = 1024 * 8

func (cache *Cache) lockAll() <span class="cov2" title="20">{
        for _, cq := range cache.cq </span><span class="cov4" title="640">{
                cq.mu.Lock()
        }</span>
}

func (cache *Cache) unlockAll() <span class="cov2" title="20">{
        for _, cq := range cache.cq </span><span class="cov4" title="640">{
                cq.mu.Unlock()
        }</span>
}

func (cache *Cache) WriteTo(w io.Writer) (n int64, err error) <span class="cov2" title="11">{
        if cache != nil </span><span class="cov2" title="11">{
                cache.lockAll()
                defer cache.unlockAll()
                err = cache.writeToLocked(w, &amp;n)
        }</span>
        <span class="cov2" title="11">return</span>
}

func (cache *Cache) ReadFrom(r io.Reader) (n int64, err error) <span class="cov2" title="9">{
        if cache != nil </span><span class="cov2" title="9">{
                var gotmagic int64
                if gotmagic, err = readInt64(r, &amp;n); err == nil </span><span class="cov2" title="9">{
                        err = ErrWrongMagic
                        if gotmagic == cacheMagic </span><span class="cov2" title="9">{
                                err = cache.readFrom(r, &amp;n)
                        }</span>
                }
        }
        <span class="cov2" title="9">return</span>
}

func marshalWorker(qc *cacheBucket, w io.Writer, n *int64, perr *error, pmu *sync.Mutex, wg *sync.WaitGroup) <span class="cov4" title="352">{
        defer wg.Done()
        var buf []byte
        wf := func() (fatal bool) </span><span class="cov7" title="39462">{
                pmu.Lock()
                defer pmu.Unlock()
                written, err := w.Write(buf)
                *n += int64(written)
                if err != nil </span><span class="cov0" title="0">{
                        fatal = (err == io.EOF || errors.Is(err, io.ErrShortWrite))
                        *perr = errors.Join(*perr, err)
                }</span>
                <span class="cov7" title="39462">buf = buf[:0]
                return</span>
        }
        <span class="cov4" title="352">for _, cv := range qc.cache </span><span class="cov10" title="3000261">{
                if b, err := cv.MarshalBinary(); err == nil </span><span class="cov9" title="3000260">{
                        if len(b) &gt; 0 </span><span class="cov9" title="3000260">{
                                if len(buf)+2+len(b) &gt; marshalWorkerBufferSize </span><span class="cov7" title="39110">{
                                        if wf() </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                                <span class="cov9" title="3000260">buf = binary.BigEndian.AppendUint16(buf, uint16(len(b))) // #nosec G115
                                buf = append(buf, b...)</span>
                        }
                } else<span class="cov1" title="1"> {
                        pmu.Lock()
                        *perr = errors.Join(*perr, err)
                        pmu.Unlock()
                }</span>
        }
        <span class="cov4" title="352">wf()</span>
}

func (cache *Cache) writeToLocked(w io.Writer, n *int64) (err error) <span class="cov2" title="11">{
        if err = writeInt64(w, n, cacheMagic); err == nil </span><span class="cov2" title="11">{
                var wg sync.WaitGroup
                var mu sync.Mutex
                for _, cq := range cache.cq </span><span class="cov4" title="352">{
                        wg.Add(1)
                        go marshalWorker(cq, w, n, &amp;err, &amp;mu, &amp;wg)
                }</span>
                <span class="cov2" title="11">wg.Wait()</span>
        }
        <span class="cov2" title="11">return</span>
}

func (cache *Cache) readFrom(r io.Reader, n *int64) (err error) <span class="cov2" title="9">{
        cache.Clear()
        cache.lockAll()
        defer cache.unlockAll()
        var readerr error
        buf := make([]byte, 512)
        for readerr == nil </span><span class="cov9" title="1000269">{
                var numread int
                numread, readerr = io.ReadFull(r, buf[:2])
                *n += int64(numread)
                if readerr == nil </span><span class="cov9" title="1000260">{
                        length := int(binary.BigEndian.Uint16(buf[:2]))
                        if length &gt; 0 </span><span class="cov9" title="1000260">{
                                if length &gt; cap(buf) </span><span class="cov0" title="0">{
                                        buf = make([]byte, length)
                                }</span>
                                <span class="cov9" title="1000260">buf = buf[:length]
                                numread, readerr = io.ReadFull(r, buf)
                                *n += int64(numread)
                                if readerr == nil </span><span class="cov9" title="1000260">{
                                        var cv cacheValue
                                        if merr := cv.UnmarshalBinary(buf); merr == nil </span><span class="cov9" title="1000260">{
                                                cache.cq[cv.bucketIndex()].setLocked(cv.Msg, cv.expires)
                                        }</span> else<span class="cov0" title="0"> {
                                                err = errors.Join(err, merr)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov2" title="9">if readerr == io.EOF </span><span class="cov2" title="9">{
                readerr = nil
        }</span>
        <span class="cov2" title="9">err = errors.Join(err, readerr)
        return</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package recursive

import (
        "encoding/binary"
        "io"
        "time"

        "github.com/miekg/dns"
)

type cacheValue struct {
        *dns.Msg       // the message (with Zero flag set)
        expires  int64 // expiry Unix time
}

func (cv cacheValue) expiresAt() time.Time <span class="cov4" title="178">{
        return time.Unix(cv.expires, 0)
}</span>

func (cv *cacheValue) MarshalBinary() (b []byte, err error) <span class="cov10" title="3000261">{
        var packed []byte
        if packed, err = cv.Pack(); err == nil </span><span class="cov9" title="3000260">{
                b = binary.AppendVarint(b, cv.expires)
                b = append(b, packed...)
        }</span>
        <span class="cov10" title="3000261">return</span>
}

func (cv *cacheValue) UnmarshalBinary(b []byte) (err error) <span class="cov9" title="1000260">{
        err = io.ErrShortBuffer
        if expiry, n := binary.Varint(b); n &gt; 0 </span><span class="cov9" title="1000260">{
                var msg dns.Msg
                if err = msg.Unpack(b[n:]); err == nil </span><span class="cov9" title="1000260">{
                        cv.Msg = &amp;msg
                        cv.expires = expiry
                }</span>
        }
        <span class="cov9" title="1000260">return</span>
}

func (cv *cacheValue) bucketIndex() int <span class="cov9" title="1000260">{
        return bucketIndexForQname(cv.Question[0].Name)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package recursive

import (
        crand "crypto/rand"
        "encoding/binary"
        "fmt"
        rand "math/rand/v2"
        "net/netip"
        "sort"
        "time"
)

var crandRead func(b []byte) (n int, err error) = crand.Read

type srvCookie struct {
        value string
        ts    time.Time
}

func makeCookie() string <span class="cov6" title="1003">{
        var b [8]byte
        n, _ := crandRead(b[:])
        x := binary.LittleEndian.Uint64(b[:])
        if n &lt; len(b) </span><span class="cov6" title="1003">{
                x ^= rand.Uint64() // #nosec G404
        }</span>
        <span class="cov6" title="1003">return fmt.Sprintf("%016x", x)</span>
}

func maskCookie(s string) string <span class="cov2" title="10">{
        if len(s) &gt; 5 </span><span class="cov2" title="9">{
                return "..." + s[len(s)-5:]
        }</span>
        <span class="cov1" title="1">return s</span>
}

// ResetCookies generates a new DNS client cookie and clears the known DNS server cookies.
func (r *Recursive) ResetCookies() <span class="cov1" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.clicookie = makeCookie()
        clear(r.srvcookies)
}</span>

func (r *Recursive) cleanupSrvCookiesLocked(now time.Time) <span class="cov2" title="8">{
        cutoff := now.Add(-srvCookieTTL)
        for addr, c := range r.srvcookies </span><span class="cov7" title="8195">{
                if c.ts.Before(cutoff) </span><span class="cov1" title="1">{
                        delete(r.srvcookies, addr)
                }</span>
        }
        <span class="cov2" title="8">if len(r.srvcookies) &lt;= maxSrvCookies </span><span class="cov2" title="7">{
                return
        }</span>
        <span class="cov1" title="1">type ac struct {
                addr netip.Addr
                ts   time.Time
        }
        l := make([]ac, 0, len(r.srvcookies))
        for addr, c := range r.srvcookies </span><span class="cov7" title="8193">{
                l = append(l, ac{addr: addr, ts: c.ts})
        }</span>
        <span class="cov1" title="1">sort.Slice(l, func(i, j int) bool </span><span class="cov10" title="111946">{ return l[i].ts.Before(l[j].ts) }</span>)
        <span class="cov1" title="1">for i := 0; len(r.srvcookies) &gt; maxSrvCookies &amp;&amp; i &lt; len(l); i++ </span><span class="cov1" title="1">{
                delete(r.srvcookies, l[i].addr)
        }</span>
}

func (r *Recursive) cleanupSrvCookies(now time.Time) <span class="cov2" title="6">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cleanupSrvCookiesLocked(now)
}</span>

func (r *Recursive) getSrvCookieLocked(addr netip.Addr) (s string, found bool) <span class="cov4" title="98">{
        c, ok := r.srvcookies[addr]
        if ok &amp;&amp; time.Since(c.ts) &lt; srvCookieTTL </span><span class="cov1" title="3">{
                s = c.value
                found = true
        }</span>
        <span class="cov4" title="98">return</span>
}

func (r *Recursive) setSrvCookie(now time.Time, addr netip.Addr, val string) <span class="cov1" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.srvcookies[addr] = srvCookie{value: val, ts: now}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package recursive

import (
        "errors"
        "net"
        "strings"
        "syscall"
)

func (r *Recursive) usingUDP() (yes bool) <span class="cov10" title="100">{
        r.mu.RLock()
        yes = r.useUDP
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) usingIPv6() (yes bool) <span class="cov8" title="39">{
        r.mu.RLock()
        yes = r.useIPv6
        r.mu.RUnlock()
        return
}</span>

func (r *Recursive) maybeDisableIPv6(err error) (disabled bool) <span class="cov2" title="2">{
        if err != nil </span><span class="cov2" title="2">{
                errstr := err.Error()
                if errors.Is(err, syscall.ENETUNREACH) || errors.Is(err, syscall.EHOSTUNREACH) ||
                        strings.Contains(errstr, "network is unreachable") || strings.Contains(errstr, "no route to host") </span><span class="cov2" title="2">{
                        r.mu.Lock()
                        defer r.mu.Unlock()
                        if r.useIPv6 </span><span class="cov2" title="2">{
                                r.useIPv6 = false
                                disabled = true
                                var idx int
                                for i := range r.rootServers </span><span class="cov3" title="4">{
                                        if r.rootServers[i].Is4() </span><span class="cov2" title="2">{
                                                r.rootServers[idx] = r.rootServers[i]
                                                idx++
                                        }</span>
                                }
                                <span class="cov2" title="2">r.rootServers = r.rootServers[:idx]</span>
                        }
                }
        }
        <span class="cov2" title="2">return</span>
}

func (r *Recursive) maybeDisableUdp(err error) (disabled bool) <span class="cov3" title="3">{
        var ne net.Error
        if errors.As(err, &amp;ne) &amp;&amp; !ne.Timeout() </span><span class="cov2" title="2">{
                errstr := (err).Error()
                if errors.Is(err, syscall.ENOSYS) || errors.Is(err, syscall.EPROTONOSUPPORT) || strings.Contains(errstr, "network not implemented") </span><span class="cov2" title="2">{
                        r.mu.Lock()
                        disabled = r.useUDP
                        r.useUDP = false
                        r.mu.Unlock()
                }</span>
        }
        <span class="cov3" title="3">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "os"

        "github.com/miekg/dns"
)

// ExtendedRcode represents a DNS Extended Error code as defined in RFC 8914.

type extendedErrorCodeError uint16

func (e extendedErrorCodeError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("extended rcode %v", uint16(e))
}</span>

func (e extendedErrorCodeError) Is(err error) bool <span class="cov2" title="2">{
        return err == ErrExtendedErrorCode
}</span>

var ErrExtendedErrorCode = extendedErrorCodeError(0)

var rcodesToErrors = map[uint16]error{
        dns.ExtendedErrorCodeOther:                io.EOF,
        dns.ExtendedErrorCodeNotReady:             io.ErrNoProgress,
        dns.ExtendedErrorCodeProhibited:           os.ErrPermission,
        dns.ExtendedErrorCodeNoReachableAuthority: os.ErrDeadlineExceeded,
        dns.ExtendedErrorCodeNetworkError:         net.ErrClosed,
        dns.ExtendedErrorCodeInvalidData:          os.ErrInvalid,
}

// ExtendedErrorCodeFromError attempts to map a Go error to a DNS Extended Rcode.
// The function understands well-known errors from the os, io, and net packages
// (including their wrapper types) and returns dns.ExtendedErrorCodeOther if no mapping is known.
func ExtendedErrorCodeFromError(err error) (rcode uint16) <span class="cov7" title="35">{
        rcode = dns.ExtendedErrorCodeOther
        if err != nil </span><span class="cov7" title="34">{
                if rcodeErr, ok := err.(extendedErrorCodeError); ok </span><span class="cov2" title="3">{
                        return uint16(rcodeErr)
                }</span>

                <span class="cov7" title="31">for code, sample := range rcodesToErrors </span><span class="cov10" title="152">{
                        if errors.Is(err, sample) </span><span class="cov5" title="13">{
                                return code
                        }</span>
                }

                <span class="cov6" title="18">if errors.Is(err, os.ErrNotExist) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNoReachableAuthority
                }</span>
                <span class="cov6" title="17">if errors.Is(err, os.ErrExist) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov5" title="16">if errors.Is(err, os.ErrDeadlineExceeded) ||
                        errors.Is(err, context.DeadlineExceeded) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNoReachableAuthority
                }</span>

                <span class="cov5" title="15">if errors.Is(err, io.ErrShortBuffer) || errors.Is(err, io.ErrShortWrite) </span><span class="cov2" title="2">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov5" title="13">if errors.Is(err, io.ErrClosedPipe) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNetworkError
                }</span>
                <span class="cov5" title="12">if errors.Is(err, io.ErrUnexpectedEOF) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>

                <span class="cov5" title="11">var unknownNet net.UnknownNetworkError
                if errors.As(err, &amp;unknownNet) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeNetworkError
                }</span>
                <span class="cov5" title="10">var addrErr *net.AddrError
                if errors.As(err, &amp;addrErr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="9">var invalidAddr net.InvalidAddrError
                if errors.As(err, &amp;invalidAddr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="8">var parseErr *net.ParseError
                if errors.As(err, &amp;parseErr) </span><span class="cov1" title="1">{
                        return dns.ExtendedErrorCodeInvalidData
                }</span>
                <span class="cov4" title="7">var dnsErr *net.DNSError
                if errors.As(err, &amp;dnsErr) </span><span class="cov3" title="4">{
                        switch </span>{
                        case dnsErr.IsTimeout, dnsErr.IsNotFound:<span class="cov2" title="2">
                                return dns.ExtendedErrorCodeNoReachableAuthority</span>
                        case dnsErr.IsTemporary:<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNotReady</span>
                        default:<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNetworkError</span>
                        }
                }

                <span class="cov2" title="3">var netErr net.Error
                if errors.As(err, &amp;netErr) </span><span class="cov2" title="3">{
                        switch </span>{
                        case netErr.Timeout():<span class="cov1" title="1">
                                return dns.ExtendedErrorCodeNoReachableAuthority</span>
                        default:<span class="cov2" title="2">
                                return dns.ExtendedErrorCodeNetworkError</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

// ErrorFromExtendedErrorCode returns the canonical Go error for the provided
// Extended Error Code. It returns ErrExtendedErrorCode if there is no known mapping.
func ErrorFromExtendedErrorCode(code uint16) (err error) <span class="cov4" title="7">{
        var ok bool
        if err, ok = rcodesToErrors[code]; !ok </span><span class="cov1" title="1">{
                err = extendedErrorCodeError(code)
        }</span>
        <span class="cov4" title="7">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package recursive

import (
        "encoding/binary"
        "io"
)

func readInt64(r io.Reader, numread *int64) (val int64, err error) <span class="cov9" title="9">{
        b := [8]byte{}
        var n int
        if n, err = io.ReadFull(r, b[:]); err == nil </span><span class="cov9" title="9">{
                val = int64(binary.BigEndian.Uint64(b[:])) //#nosec
        }</span>
        <span class="cov9" title="9">*numread += int64(n)
        return</span>
}

func writeInt64(w io.Writer, written *int64, val int64) (err error) <span class="cov10" title="11">{
        b := [8]byte{}
        binary.BigEndian.PutUint64(b[:], uint64(val)) //#nosec
        var n int
        n, err = w.Write(b[:])
        *written += int64(n)
        return
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package recursive

import "time"

type netError struct {
        Err  error
        When time.Time
}

func (ne netError) Error() string <span class="cov8" title="1">{
        return ne.Err.Error()
}</span>

func (ne netError) Unwrap() error <span class="cov8" title="1">{
        return ne.Err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sort"
        "sync"
        "time"
)

func (r *Recursive) OrderRoots(ctx context.Context) <span class="cov1" title="1">{
        r.OrderRootsTimeout(ctx, time.Second)
}</span>

// OrderRootsTimeout sorts the root server list by their current latency and removes those that don't respond within cutoff.
func (r *Recursive) OrderRootsTimeout(ctx context.Context, cutoff time.Duration) <span class="cov2" title="2">{
        if _, ok := ctx.Deadline(); !ok </span><span class="cov2" title="2">{
                newctx, cancel := context.WithTimeout(ctx, cutoff*2)
                defer cancel()
                ctx = newctx
        }</span>
        <span class="cov2" title="2">r.mu.Lock()
        defer r.mu.Unlock()
        var l []*rootRtt
        var wg sync.WaitGroup
        for _, addr := range r.rootServers </span><span class="cov7" title="52">{
                rt := &amp;rootRtt{addr: addr}
                l = append(l, rt)
                wg.Add(1)
                go timeRoot(ctx, r, &amp;wg, rt)
        }</span>
        <span class="cov2" title="2">wg.Wait()
        sort.Slice(l, func(i, j int) bool </span><span class="cov10" title="165">{ return l[i].rtt &lt; l[j].rtt }</span>)
        <span class="cov2" title="2">var newRootServers []netip.Addr
        useIPv4 := false
        useIPv6 := false
        for _, rt := range l </span><span class="cov7" title="52">{
                if rt.rtt &lt;= cutoff </span><span class="cov6" title="23">{
                        useIPv4 = useIPv4 || rt.addr.Is4()
                        useIPv6 = useIPv6 || rt.addr.Is6()
                        newRootServers = append(newRootServers, rt.addr)
                }</span>
        }
        <span class="cov2" title="2">if len(newRootServers) &gt; 0 </span><span class="cov2" title="2">{
                r.rootServers = newRootServers
                r.useIPv4 = useIPv4
                r.useIPv6 = useIPv6
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package recursive

import (
        "context"
        "fmt"
        "io"
        "math/rand/v2"
        "net"
        "net/netip"
        "slices"
        "sort"
        "strings"
        "time"

        "github.com/miekg/dns"
)

type query struct {
        *Recursive
        cache Cacher
        logw  io.Writer
        start time.Time
        depth int
        steps int
        glue  map[string][]netip.Addr
}

func (q *query) dive(format string, args ...any) (err error) <span class="cov5" title="122">{
        err = ErrMaxSteps
        if q.steps &lt; maxSteps </span><span class="cov5" title="122">{
                q.steps++
                err = ErrMaxDepth
                if q.depth &lt; maxDepth </span><span class="cov5" title="122">{
                        err = nil
                        if format != "" </span><span class="cov5" title="122">{
                                q.logf(format, args...)
                        }</span>
                        <span class="cov5" title="122">q.depth++</span>
                }
        }
        <span class="cov5" title="122">return</span>
}

func (q *query) surface() <span class="cov5" title="122">{
        q.depth--
}</span>

func (q *query) resolve(ctx context.Context, qname string, qtype uint16) (resp *dns.Msg, srv netip.Addr, err error) <span class="cov5" title="71">{
        var servers []netip.Addr
        qname = dns.CanonicalName(qname)
        if servers, resp, srv, err = q.queryDelegation(ctx, qname); err == nil </span><span class="cov5" title="70">{
                if resp != nil &amp;&amp; resp.Rcode == dns.RcodeNameError </span><span class="cov4" title="37">{
                        // no need to query final
                        if resp.Question[0].Qtype != qtype </span><span class="cov4" title="37">{
                                if resp.Zero </span><span class="cov4" title="33">{
                                        resp = resp.Copy()
                                        resp.Zero = false
                                }</span>
                                <span class="cov4" title="37">resp.Question[0].Qtype = qtype</span>
                        }
                } else<span class="cov4" title="33"> {
                        resp, srv, err = q.queryFinal(ctx, qname, qtype, servers)
                }</span>
        }
        <span class="cov5" title="71">return</span>
}

func (q *query) queryDelegation(ctx context.Context, qname string) (servers []netip.Addr, resp *dns.Msg, srv netip.Addr, err error) <span class="cov5" title="71">{
        if err = q.dive("DELEGATION QUERY %q\n", qname); err == nil </span><span class="cov5" title="71">{
                defer func() </span><span class="cov5" title="71">{
                        q.surface()
                        rcode := "UNKNOWN"
                        if resp != nil </span><span class="cov5" title="70">{
                                rcode = dns.RcodeToString[resp.Rcode]
                        }</span> else<span class="cov1" title="1"> if err != nil </span><span class="cov1" title="1">{
                                rcode = err.Error()
                        }</span>
                        <span class="cov5" title="71">q.logf("DELEGATION ANSWER %q: %s with %d servers\n", qname, rcode, len(servers))</span>
                }()

                <span class="cov5" title="71">servers = append([]netip.Addr(nil), q.rootServers...)
                labels := dns.SplitDomainName(qname)

                // Walk down: "." -&gt; "com." -&gt; "example.com."
                for i := len(labels) - 1; i &gt;= 0; i-- </span><span class="cov6" title="228">{
                        zone := dns.Fqdn(strings.Join(labels[i:], "."))
                        var nsAddrs []netip.Addr

                        if nsAddrs, resp, srv, err = q.queryForDelegation(ctx, zone, servers, qname); err != nil </span><span class="cov1" title="1">{
                                q.logf("DELEGATION ERROR %q: %v\n", zone, err)
                                return
                        }</span>

                        <span class="cov6" title="227">if len(nsAddrs) &gt; 0 </span><span class="cov6" title="145">{
                                // got a new set of servers to query
                                servers = q.sortAddrs(nsAddrs)
                        }</span>
                }
        }
        <span class="cov5" title="70">return</span>
}

// queryForDelegation performs the QMIN step at `zone` against `parentServers`.
// If servers REFUSE/NOTIMP the minimized NS query, retry with non-QMIN (ask NS for the full qname).
func (q *query) queryForDelegation(ctx context.Context, zone string, parentServers []netip.Addr, fullQname string) (nsAddrs []netip.Addr, resp *dns.Msg, srv netip.Addr, err error) <span class="cov6" title="228">{
        var nsNames []string
retryWithoutQMIN:
        for _, srv = range parentServers </span><span class="cov6" title="274">{
                if resp, err = q.exchange(ctx, zone, dns.TypeNS, srv); resp != nil &amp;&amp; err == nil </span><span class="cov6" title="274">{
                        if resp.Rcode != dns.RcodeSuccess </span><span class="cov4" title="38">{
                                if resp.Rcode != dns.RcodeNameError </span><span class="cov0" title="0">{
                                        // probably dns.RcodeRefused or dns.RcodeNotImplemented, retry without QMIN
                                        if zone != fullQname </span><span class="cov0" title="0">{
                                                q.logf("DELEGATION RETRY without QNAME minimization\n")
                                                zone = fullQname
                                                goto retryWithoutQMIN</span>
                                        }
                                }
                                // NXDOMAIN at parent or we failed even without QMIN
                                <span class="cov4" title="38">return</span>
                        }

                        <span class="cov6" title="236">nsNames, nsAddrs = q.extractDelegationNS(resp, zone)
                        if len(nsNames) &gt; 0 </span><span class="cov6" title="157">{
                                if len(nsAddrs) == 0 </span><span class="cov3" title="18">{
                                        nsAddrs = q.resolveNSAddrs(ctx, nsNames)
                                }</span>
                        }
                        <span class="cov6" title="236">if len(nsAddrs) &gt; 0 || resp.Authoritative </span><span class="cov6" title="185">{
                                return
                        }</span>
                }
        }

        <span class="cov2" title="5">if resp == nil &amp;&amp; err == nil </span><span class="cov1" title="1">{
                err = ErrNoResponse
        }</span>

        <span class="cov2" title="5">return</span>
}

func (q *query) extractDelegationNS(m *dns.Msg, zone string) (nsNames []string, nsAddr []netip.Addr) <span class="cov6" title="236">{
        // extract delegation NS records
        for _, rr := range m.Ns </span><span class="cov8" title="1188">{
                if ns, ok := rr.(*dns.NS); ok </span><span class="cov8" title="1165">{
                        if strings.EqualFold(ns.Hdr.Name, zone) </span><span class="cov8" title="1124">{
                                nsName := dns.CanonicalName(ns.Ns)
                                if !slices.Contains(nsNames, nsName) </span><span class="cov8" title="1124">{
                                        nsNames = append(nsNames, nsName)
                                }</span>
                        }
                }
        }
        // extract glue records
        <span class="cov6" title="236">for _, rr := range m.Extra </span><span class="cov8" title="2136">{
                var addr netip.Addr
                switch a := rr.(type) </span>{
                case *dns.A:<span class="cov7" title="1025">
                        addr = ipToAddr(a.A)</span>
                case *dns.AAAA:<span class="cov7" title="914">
                        addr = ipToAddr(a.AAAA)</span>
                }
                <span class="cov8" title="2136">if addr.IsValid() </span><span class="cov8" title="1939">{
                        hdrName := dns.CanonicalName(rr.Header().Name)
                        if slices.Contains(nsNames, hdrName) </span><span class="cov8" title="1935">{
                                if !slices.Contains(q.glue[hdrName], addr) </span><span class="cov6" title="269">{
                                        q.glue[hdrName] = append(q.glue[hdrName], addr)
                                }</span>
                        }
                }
        }
        // build list of addresses belonging to nsNames
        <span class="cov6" title="236">addrs := map[netip.Addr]struct{}{}
        for _, nsName := range nsNames </span><span class="cov8" title="1124">{
                for _, addr := range q.glue[nsName] </span><span class="cov8" title="1939">{
                        addrs[addr] = struct{}{}
                }</span>
        }
        <span class="cov6" title="236">for addr := range addrs </span><span class="cov8" title="1939">{
                nsAddr = append(nsAddr, addr)
        }</span>
        <span class="cov6" title="236">return</span>
}

// queryFinal asks the authoritative (or closest) servers for the target qname/qtype.
// It also performs CNAME/DNAME chasing, with a loop bound controlled by depth.
func (q *query) queryFinal(ctx context.Context, qname string, qtype uint16, authServers []netip.Addr) (resp *dns.Msg, svr netip.Addr, err error) <span class="cov4" title="33">{
        if err = q.dive("QUERY %s %q from %d servers\n", dns.Type(qtype), qname, len(authServers)); err == nil </span><span class="cov4" title="33">{
                defer func() </span><span class="cov4" title="33">{
                        q.surface()
                        q.logf("ANSWER @%s %s %q", svr, dns.Type(qtype), qname)
                        q.logResponse(0, resp, err)
                }</span>()
                <span class="cov4" title="33">for _, svr = range authServers </span><span class="cov4" title="33">{
                        if resp, err = q.exchange(ctx, qname, qtype, svr); resp != nil &amp;&amp; err == nil </span><span class="cov4" title="33">{
                                if resp.Rcode == dns.RcodeSuccess </span><span class="cov4" title="33">{
                                        if !hasRRType(resp.Answer, qtype) </span><span class="cov3" title="8">{
                                                if tgt := cnameTarget(resp, qname); tgt != "" </span><span class="cov2" title="7">{
                                                        q.logf("CNAME @%s %s %q =&gt; %q\n", svr, dns.Type(qtype), qname, tgt)
                                                        var msg *dns.Msg
                                                        var origin netip.Addr
                                                        msg, origin, err = q.resolve(ctx, tgt, qtype)
                                                        if err == nil </span><span class="cov2" title="7">{
                                                                msg = cloneIfCached(msg)
                                                                prependRecords(msg, resp, qname, cnameChainRecords)
                                                                resp = msg
                                                                svr = origin
                                                        }</span>
                                                } else<span class="cov1" title="1"> if tgt := dnameSynthesize(resp, qname); tgt != "" </span><span class="cov0" title="0">{
                                                        q.logf("DNAME @%s %s %q =&gt; %q\n", svr, dns.Type(qtype), qname, tgt)
                                                        var msg *dns.Msg
                                                        var origin netip.Addr
                                                        msg, origin, err = q.resolve(ctx, tgt, qtype)
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                msg = cloneIfCached(msg)
                                                                prependRecords(msg, resp, qname, dnameRecords)
                                                                resp = msg
                                                                svr = origin
                                                        }</span>
                                                } else<span class="cov1" title="1"> if qtype == dns.TypeNS </span><span class="cov1" title="1">{
                                                        answers := delegationRecords(resp, qname)
                                                        if len(answers) &gt; 0 </span><span class="cov1" title="1">{
                                                                // returning parent delegation
                                                                resp = resp.Copy()
                                                                resp.Zero = false
                                                                resp.Answer = answers
                                                                resp.Extra = nil
                                                                resp.Ns = nil
                                                        }</span>
                                                }
                                        }
                                        <span class="cov4" title="33">return</span>
                                }

                                <span class="cov0" title="0">if resp.Rcode == dns.RcodeNameError </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // got an unhandled RCODE, try the next server
                        }
                }

                <span class="cov0" title="0">if resp == nil &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        err = ErrNoResponse
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// resolveNSAddrs minimally resolves NS owner names to addresses by asking the roots when glue is missing
func (q *query) resolveNSAddrs(ctx context.Context, nsOwners []string) (addrs []netip.Addr) <span class="cov3" title="18">{
        if q.dive("GLUE QUERY %v\n", nsOwners) == nil </span><span class="cov3" title="18">{
                defer func() </span><span class="cov3" title="18">{
                        q.surface()
                        q.logf("GLUE ANSWER %v\n", addrs)
                }</span>()
                <span class="cov3" title="18">resolved := map[netip.Addr]struct{}{}
                for _, host := range nsOwners </span><span class="cov5" title="58">{
                        if msg, _, err := q.resolve(ctx, dns.CanonicalName(host), dns.TypeA); err == nil </span><span class="cov5" title="58">{
                                for _, rr := range msg.Answer </span><span class="cov4" title="22">{
                                        if a, ok := rr.(*dns.A); ok </span><span class="cov4" title="22">{
                                                if addr := ipToAddr(a.A); addr.IsValid() </span><span class="cov4" title="22">{
                                                        resolved[addr] = struct{}{}
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov5" title="58">if len(resolved) == 0 &amp;&amp; q.usingIPv6() </span><span class="cov0" title="0">{
                                if msg, _, err := q.resolve(ctx, dns.CanonicalName(host), dns.TypeAAAA); err == nil </span><span class="cov0" title="0">{
                                        for _, rr := range msg.Answer </span><span class="cov0" title="0">{
                                                if a, ok := rr.(*dns.AAAA); ok </span><span class="cov0" title="0">{
                                                        if addr := ipToAddr(a.AAAA); addr.IsValid() </span><span class="cov0" title="0">{
                                                                resolved[addr] = struct{}{}
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
                <span class="cov3" title="18">for addr := range resolved </span><span class="cov4" title="22">{
                        addrs = append(addrs, addr)
                }</span>
        }
        <span class="cov3" title="18">return</span>
}

func (q *query) logf(format string, args ...any) <span class="cov7" title="559">{
        if q.logw != nil </span><span class="cov7" title="556">{
                _, _ = fmt.Fprintf(q.logw, "[%-5d %2d] %*s", time.Since(q.start).Milliseconds(), q.depth, q.depth, "")
                _, _ = fmt.Fprintf(q.logw, format, args...)
        }</span>
}

func (q *query) logResponse(rtt time.Duration, msg *dns.Msg, err error) <span class="cov6" title="340">{
        if q.logw != nil </span><span class="cov6" title="340">{
                if msg != nil </span><span class="cov6" title="340">{
                        var elapsed string
                        if rtt != 0 </span><span class="cov5" title="98">{
                                elapsed = fmt.Sprintf("%v, ", rtt.Round(time.Millisecond))
                        }</span>
                        <span class="cov6" title="340">fmt.Fprintf(q.logw, " =&gt; %s [%v+%v+%v A/N/E] (%s%d bytes",
                                dns.RcodeToString[msg.Rcode],
                                len(msg.Answer), len(msg.Ns), len(msg.Extra),
                                elapsed, msg.Len())
                        if msg.MsgHdr.Truncated </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " TRNC")
                        }</span>
                        <span class="cov6" title="340">if msg.MsgHdr.Authoritative </span><span class="cov5" title="140">{
                                fmt.Fprintf(q.logw, " AUTH")
                        }</span>
                        <span class="cov6" title="340">if opt := msg.IsEdns0(); opt != nil </span><span class="cov6" title="298">{
                                if er := uint16(opt.ExtendedRcode()); /*#nosec G115*/ er != 0 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(q.logw, " EDNS=%s", dns.ExtendedErrorCodeToString[er])
                                }</span>
                        }
                        <span class="cov6" title="340">fmt.Fprintf(q.logw, ")")</span>
                }
                <span class="cov6" title="340">if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(q.logw, " ERROR: %v", err)
                }</span>
                <span class="cov6" title="340">fmt.Fprintln(q.logw)</span>
        }
}

func (q *query) exchange(ctx context.Context, qname string, qtype uint16, nsaddr netip.Addr) (resp *dns.Msg, err error) <span class="cov6" title="307">{
        if q.cache != nil </span><span class="cov6" title="307">{
                if resp = q.cache.DnsGet(qname, qtype); resp != nil </span><span class="cov6" title="209">{
                        q.logf("CACHED: %s %q", dns.Type(qtype), qname)
                        q.logResponse(0, resp, nil)
                        return
                }</span>
        }
        <span class="cov5" title="98">if q.usingUDP() </span><span class="cov5" title="98">{
                if resp, err = q.exchangeWithNetwork(ctx, "udp", qname, qtype, nsaddr); err != nil </span><span class="cov0" title="0">{
                        if q.maybeDisableUdp(err) </span><span class="cov0" title="0">{
                                err = nil
                        }</span>
                }
        }
        <span class="cov5" title="98">if err == nil &amp;&amp; (resp == nil || resp.Truncated) </span><span class="cov0" title="0">{
                resp, err = q.exchangeWithNetwork(ctx, "tcp", qname, qtype, nsaddr)
        }</span>
        <span class="cov5" title="98">if resp != nil &amp;&amp; q.cache != nil </span><span class="cov5" title="98">{
                q.cache.DnsSet(resp)
        }</span>
        <span class="cov5" title="98">return</span>
}

func (q *query) exchangeWithNetwork(ctx context.Context, protocol string, qname string, qtype uint16, nsaddr netip.Addr) (msg *dns.Msg, err error) <span class="cov5" title="98">{
        if err = q.getUsable(ctx, protocol, nsaddr); err == nil </span><span class="cov5" title="98">{
                var network string
                if nsaddr.Is4() </span><span class="cov5" title="98">{
                        network = protocol + "4"
                }</span> else<span class="cov0" title="0"> {
                        network = protocol + "6"
                }</span>

                <span class="cov5" title="98">if q.rateLimiter != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                err = ctx.Err()
                                return</span>
                        case &lt;-q.rateLimiter:<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov5" title="98">if q.logw != nil </span><span class="cov5" title="98">{
                        var protostr string
                        var dash6str string
                        if protocol != "udp" </span><span class="cov0" title="0">{
                                protostr = " +" + protocol
                        }</span>
                        <span class="cov5" title="98">if nsaddr.Is6() </span><span class="cov0" title="0">{
                                dash6str = " -6"
                        }</span>
                        <span class="cov5" title="98">q.logf("SENDING %s: @%s%s%s %s %q", network, nsaddr, protostr, dash6str, dns.Type(qtype), qname)</span>
                }

                <span class="cov5" title="98">var nconn net.Conn
                var rtt time.Duration

                q.mu.RLock()
                if q.Timeout &gt; 0 </span><span class="cov5" title="98">{
                        ctx2, cancel := context.WithTimeout(ctx, q.Timeout)
                        defer cancel()
                        ctx = ctx2
                }</span>
                <span class="cov5" title="98">clicookie := q.clicookie
                srvcookie, hasSrvCookie := q.getSrvCookieLocked(nsaddr)
                msgsize := q.MsgSize
                q.mu.RUnlock()

                if nconn, err = q.DialContext(ctx, network, netip.AddrPortFrom(nsaddr, q.DNSPort).String()); err == nil </span><span class="cov5" title="98">{
                        dnsconn := &amp;dns.Conn{Conn: nconn, UDPSize: msgsize}
                        defer dnsconn.Close()

                        m := new(dns.Msg)
                        m.SetQuestion(qname, qtype)
                        m.RecursionDesired = false
                        opt := new(dns.OPT)
                        opt.Hdr.Name = "."
                        opt.Hdr.Rrtype = dns.TypeOPT
                        opt.SetUDPSize(msgsize)

                        // an existing but empty string for srvcookie means cookies are disabled for this server
                        useCookies := !hasSrvCookie || srvcookie != ""
                        if useCookies </span><span class="cov5" title="98">{
                                opt.Option = append(opt.Option, &amp;dns.EDNS0_COOKIE{
                                        Code:   dns.EDNS0COOKIE,
                                        Cookie: clicookie + srvcookie,
                                })
                                if hasSrvCookie &amp;&amp; q.logw != nil </span><span class="cov2" title="3">{
                                        fmt.Fprintf(q.logw, " COOKIE:\"%s|%s\"", maskCookie(clicookie), maskCookie(srvcookie))
                                }</span>
                        }

                        <span class="cov5" title="98">m.Extra = append(m.Extra, opt)
                        c := dns.Client{UDPSize: msgsize}
                        msg, rtt, err = c.ExchangeWithConnContext(ctx, m, dnsconn)

                        if useCookies &amp;&amp; msg != nil </span><span class="cov5" title="98">{
                                newsrvcookie := srvcookie
                                if opt := msg.IsEdns0(); opt != nil </span><span class="cov5" title="98">{
                                        for _, rr := range opt.Option </span><span class="cov2" title="5">{
                                                switch rr := rr.(type) </span>{
                                                case *dns.EDNS0_COOKIE:<span class="cov2" title="5">
                                                        if after, ok := strings.CutPrefix(rr.Cookie, clicookie); ok </span><span class="cov2" title="5">{
                                                                newsrvcookie = after
                                                        }</span> else<span class="cov0" title="0"> {
                                                                msg = nil
                                                                err = ErrInvalidCookie
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov5" title="98">if err == nil &amp;&amp; newsrvcookie != "" </span><span class="cov2" title="5">{
                                        if !hasSrvCookie || srvcookie != newsrvcookie </span><span class="cov1" title="2">{
                                                if q.logw != nil </span><span class="cov1" title="2">{
                                                        fmt.Fprintf(q.logw, " SETCOOKIE:\"%s\"", maskCookie(newsrvcookie))
                                                }</span>
                                                <span class="cov1" title="2">q.setSrvCookie(q.start, nsaddr, newsrvcookie)</span>
                                        }
                                }
                        }
                }

                <span class="cov5" title="98">isIpv6Err, isUdpErr := q.setNetError(protocol, nsaddr, err)
                ipv6disabled := isIpv6Err &amp;&amp; q.maybeDisableIPv6(err)
                udpDisabled := isUdpErr &amp;&amp; q.maybeDisableUdp(err)

                if q.logw != nil </span><span class="cov5" title="98">{
                        if ipv6disabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (IPv6 disabled)")
                        }</span>
                        <span class="cov5" title="98">if udpDisabled </span><span class="cov0" title="0">{
                                fmt.Fprintf(q.logw, " (UDP disabled)")
                        }</span>
                        <span class="cov5" title="98">q.logResponse(rtt, msg, err)</span>
                }

                <span class="cov5" title="98">if !hasSrvCookie &amp;&amp; msg != nil &amp;&amp; msg.Rcode == dns.RcodeFormatError </span><span class="cov0" title="0">{
                        q.logf("got FORMERR, disabling cookies for %v and retrying\n", nsaddr)
                        q.setSrvCookie(q.start, nsaddr, "")
                        return q.exchangeWithNetwork(ctx, protocol, qname, qtype, nsaddr)
                }</span>
        }
        <span class="cov5" title="98">return</span>
}

func (r *Recursive) getUsable(ctx context.Context, protocol string, nsaddr netip.Addr) (err error) <span class="cov5" title="98">{
        if err = ctx.Err(); err == nil </span><span class="cov5" title="98">{
                var m map[netip.Addr]netError
                switch protocol </span>{
                case "udp", "udp4", "udp6":<span class="cov5" title="98">
                        m = r.udperrs</span>
                case "tcp", "tcp4", "tcp6":<span class="cov0" title="0">
                        m = r.tcperrs</span>
                }
                <span class="cov5" title="98">err = net.ErrClosed
                if m != nil </span><span class="cov5" title="98">{
                        r.mu.RLock()
                        ne, hasNetError := m[nsaddr]
                        if !hasNetError </span><span class="cov5" title="98">{
                                if (r.useIPv4 &amp;&amp; nsaddr.Is4()) || (r.useIPv6 &amp;&amp; nsaddr.Is6()) </span><span class="cov5" title="98">{
                                        err = nil
                                }</span>
                        }
                        <span class="cov5" title="98">r.mu.RUnlock()
                        if hasNetError </span><span class="cov0" title="0">{
                                err = ne
                                if time.Since(ne.When) &gt; time.Minute </span><span class="cov0" title="0">{
                                        err = nil
                                        r.mu.Lock()
                                        delete(m, nsaddr)
                                        r.mu.Unlock()
                                }</span>
                        }
                }
        }
        <span class="cov5" title="98">return</span>
}

func (r *Recursive) sortAddrs(in []netip.Addr) []netip.Addr <span class="cov6" title="145">{
        if r.Deterministic </span><span class="cov6" title="145">{
                sort.Slice(in, func(i, j int) bool </span><span class="cov10" title="7491">{ return in[i].Compare(in[j]) &lt; 0 }</span>)
        } else<span class="cov0" title="0"> {
                rand.Shuffle(len(in), func(i, j int) </span><span class="cov0" title="0">{ in[i], in[j] = in[j], in[i] }</span>)
        }
        <span class="cov6" title="145">return in</span>
}

func cnameTarget(resp *dns.Msg, owner string) (tgt string) <span class="cov3" title="8">{
        for _, rr := range resp.Answer </span><span class="cov2" title="7">{
                if c, ok := rr.(*dns.CNAME); ok &amp;&amp; strings.EqualFold(c.Hdr.Name, owner) </span><span class="cov2" title="7">{
                        tgt = dns.CanonicalName(c.Target)
                }</span>
        }
        <span class="cov3" title="8">return</span>
}

// dnameSynthesize finds a DNAME and synthesizes the new qname per RFC 6672.
func dnameSynthesize(resp *dns.Msg, qname string) (tgt string) <span class="cov1" title="1">{
        q := strings.ToLower(qname)
        for _, rr := range resp.Answer </span><span class="cov0" title="0">{
                if d, ok := rr.(*dns.DNAME); ok </span><span class="cov0" title="0">{
                        owner := strings.ToLower(d.Hdr.Name)
                        if strings.HasSuffix(q, owner) </span><span class="cov0" title="0">{
                                prefix := strings.TrimSuffix(q, owner)
                                // Avoid double dots when concatenating
                                prefix = strings.TrimSuffix(prefix, ".")
                                tgt = dns.CanonicalName(strings.Trim(prefix, ".") + "." + d.Target)
                                break</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}

func hasRRType(rrs []dns.RR, t uint16) bool <span class="cov4" title="33">{
        for _, rr := range rrs </span><span class="cov4" title="32">{
                if rr.Header().Rrtype == t </span><span class="cov4" title="25">{
                        return true
                }</span>
        }
        <span class="cov3" title="8">return false</span>
}

func delegationRecords(m *dns.Msg, zone string) (out []dns.RR) <span class="cov1" title="1">{
        if m != nil </span><span class="cov1" title="1">{
                for _, rr := range m.Ns </span><span class="cov2" title="3">{
                        if ns, ok := rr.(*dns.NS); ok </span><span class="cov2" title="3">{
                                if strings.EqualFold(ns.Hdr.Name, zone) </span><span class="cov2" title="3">{
                                        out = append(out, rr)
                                }</span>
                        }
                }
        }
        <span class="cov1" title="1">return</span>
}
func cnameChainRecords(rrs []dns.RR, owner string) []dns.RR <span class="cov3" title="8">{
        var out []dns.RR
        for _, rr := range rrs </span><span class="cov3" title="8">{
                if cname, ok := rr.(*dns.CNAME); ok </span><span class="cov3" title="8">{
                        if strings.EqualFold(cname.Hdr.Name, owner) </span><span class="cov3" title="8">{
                                out = append(out, rr)
                        }</span>
                }
        }
        <span class="cov3" title="8">return out</span>
}

func dnameRecords(rrs []dns.RR, qname string) []dns.RR <span class="cov1" title="1">{
        var out []dns.RR
        for _, rr := range rrs </span><span class="cov2" title="3">{
                if d, ok := rr.(*dns.DNAME); ok </span><span class="cov1" title="1">{
                        if strings.HasSuffix(strings.ToLower(qname), strings.ToLower(d.Hdr.Name)) </span><span class="cov1" title="1">{
                                out = append(out, rr)
                        }</span>
                }
                <span class="cov2" title="3">if cname, ok := rr.(*dns.CNAME); ok </span><span class="cov1" title="1">{
                        if strings.EqualFold(cname.Hdr.Name, qname) </span><span class="cov1" title="1">{
                                out = append(out, rr)
                        }</span>
                }
        }
        <span class="cov1" title="1">return out</span>
}

func prependRecords(msg *dns.Msg, resp *dns.Msg, qname string, gather func([]dns.RR, string) []dns.RR) <span class="cov3" title="8">{
        records := gather(resp.Answer, qname)
        if len(msg.Question) &gt; 0 </span><span class="cov3" title="8">{
                msg.Question[0].Name = qname
        }</span>
        <span class="cov3" title="8">if len(records) &gt; 0 </span><span class="cov3" title="8">{
                msg.Answer = append(append([]dns.RR(nil), records...), msg.Answer...)
        }</span>
        <span class="cov3" title="8">if len(msg.Ns) == 0 </span><span class="cov0" title="0">{
                if len(resp.Ns) &gt; 0 </span><span class="cov0" title="0">{
                        msg.Ns = append([]dns.RR(nil), resp.Ns...)
                }</span>
        }
        <span class="cov3" title="8">if len(resp.Extra) &gt; 0 </span><span class="cov2" title="7">{
                extras := append([]dns.RR(nil), resp.Extra...)
                msg.Extra = append(extras, msg.Extra...)
        }</span>
}

func ipToAddr(ip net.IP) (addr netip.Addr) <span class="cov8" title="1961">{
        if ip != nil </span><span class="cov8" title="1961">{
                if v4 := ip.To4(); v4 != nil </span><span class="cov8" title="1047">{
                        addr = netip.AddrFrom4([4]byte(v4))
                }</span> else<span class="cov7" title="914"> if v6 := ip.To16(); v6 != nil </span><span class="cov7" title="914">{
                        addr = netip.AddrFrom16([16]byte(v6))
                }</span>
        }
        <span class="cov8" title="1961">return</span>
}

func cloneIfCached(msg *dns.Msg) (clone *dns.Msg) <span class="cov3" title="9">{
        clone = msg
        if msg.Zero </span><span class="cov1" title="1">{
                clone = msg.Copy()
                clone.Zero = false
        }</span>
        <span class="cov3" title="9">return</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// package recursive provides a minimal iterative DNS resolver with QNAME minimization
// using github.com/miekg/dns for wire format and transport.
package recursive

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net"
        "net/netip"
        "os"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/miekg/dns"
        "golang.org/x/net/proxy"
)

//go:generate go run ./cmd/genhints roothints.gen.go

const (
        maxSrvCookies = 8192
        srvCookieTTL  = 24 * time.Hour
        maxDepth      = 16   // max recursion depth
        maxSteps      = 4096 // max steps to take for a query
)

type Recursive struct {
        proxy.ContextDialer                 // context dialer to use
        Cacher                              // cache to use for DnsResolve
        Timeout             time.Duration   // default is DefaultTimeout
        DNSPort             uint16          // default is DefaultDNSPort
        Deterministic       bool            // if true, always query nameservers in the same order
        MsgSize             uint16          // UDP message size
        rateLimiter         &lt;-chan struct{} // (read-only) rate limited passed to NewWithOptions
        mu                  sync.RWMutex    // protects following
        useIPv4             bool
        useIPv6             bool
        useUDP              bool
        rootServers         []netip.Addr
        clicookie           string
        srvcookies          map[netip.Addr]srvCookie
        udperrs             map[netip.Addr]netError
        tcperrs             map[netip.Addr]netError
}

func (r *Recursive) DnsResolve(ctx context.Context, qname string, qtype uint16) (msg *dns.Msg, srv netip.Addr, err error) <span class="cov1" title="1">{
        return r.ResolveWithOptions(ctx, r.Cacher, nil, qname, qtype)
}</span>

var _ Resolver = &amp;Recursive{}

var (
        // ErrInvalidCookie is returned if the DNS cookie from the server is invalid.
        ErrInvalidCookie = errors.New("invalid cookie")
        // ErrMaxDepth is returned when recursive resolving exceeds the allowed limit.
        ErrMaxDepth = fmt.Errorf("recursion depth exceeded %d", maxDepth)
        // ErrMaxSteps is returned when resolving exceeds the step limit.
        ErrMaxSteps = fmt.Errorf("resolve steps exceeded %d", maxSteps)
        // ErrNoResponse is returned when no authoritative server could be successfully queried.
        // It is equivalent to SERVFAIL.
        ErrNoResponse = errors.New("no authoritative response")

        DefaultCache          = NewCache()
        DefaultTimeout        = time.Second * 3
        DefaultDNSPort uint16 = 53
        DefaultMsgSize uint16 = 1232 // default UDP message size
)

// NewWithOptions returns a new Recursive resolver using the given ContextDialer and
// using the given Cacher as the cache when calling DnsResolve. It does not call OrderRoots.
//
// Passing nil for dialer will use a net.Dialer.
// Passing nil for the roots will use the default set of roots.
// Passing nil for the rateLimiter means no rate limiting
func NewWithOptions(dialer proxy.ContextDialer, cache Cacher, roots4, roots6 []netip.Addr, rateLimiter &lt;-chan struct{}) *Recursive <span class="cov2" title="2">{
        if dialer == nil </span><span class="cov2" title="2">{
                dialer = &amp;net.Dialer{}
        }</span>
        <span class="cov2" title="2">if roots4 == nil </span><span class="cov2" title="2">{
                roots4 = Roots4
        }</span>
        <span class="cov2" title="2">if roots6 == nil </span><span class="cov2" title="2">{
                roots6 = Roots6
        }</span>

        <span class="cov2" title="2">var roots []netip.Addr
        roots = append(roots, roots4...)
        roots = append(roots, roots6...)

        return &amp;Recursive{
                ContextDialer: dialer,
                Cacher:        cache,
                DNSPort:       DefaultDNSPort,
                Timeout:       DefaultTimeout,
                MsgSize:       DefaultMsgSize,
                rateLimiter:   rateLimiter,
                useUDP:        true,
                useIPv4:       len(roots4) &gt; 0,
                useIPv6:       len(roots6) &gt; 0,
                rootServers:   roots,
                clicookie:     makeCookie(),
                srvcookies:    make(map[netip.Addr]srvCookie),
                udperrs:       make(map[netip.Addr]netError),
                tcperrs:       make(map[netip.Addr]netError),
        }</span>
}

// New returns a new Recursive resolver using the given ContextDialer and
// has DefaultCache as it's cache.
//
// It calls OrderRoots before returning.
func New(dialer proxy.ContextDialer) *Recursive <span class="cov1" title="1">{
        r := NewWithOptions(dialer, DefaultCache, nil, nil, nil)
        r.OrderRoots(context.Background())
        return r
}</span>

// ResolveWithOptions performs iterative resolution with QNAME minimization for qname/qtype.
func (r *Recursive) ResolveWithOptions(ctx context.Context, cache Cacher, logw io.Writer, qname string, qtype uint16) (msg *dns.Msg, origin netip.Addr, err error) <span class="cov4" title="6">{
        now := time.Now()
        r.cleanupSrvCookies(now)
        qry := query{
                Recursive: r,
                cache:     cache,
                logw:      logw,
                start:     now,
                glue:      make(map[string][]netip.Addr),
        }
        msg, origin, err = qry.resolve(ctx, dns.CanonicalName(qname), qtype)
        return
}</span>

// GetRoots returns the current set of root servers in use.
func (r *Recursive) GetRoots() (root4, root6 []netip.Addr) <span class="cov1" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, addr := range r.rootServers </span><span class="cov2" title="2">{
                if addr.Is4() </span><span class="cov1" title="1">{
                        root4 = append(root4, addr)
                }</span>
                <span class="cov2" title="2">if addr.Is6() </span><span class="cov1" title="1">{
                        root6 = append(root6, addr)
                }</span>
        }
        <span class="cov1" title="1">return</span>
}

func (r *Recursive) setNetError(protocol string, nsaddr netip.Addr, err error) (isIpv6err, isUdpErr bool) <span class="cov10" title="101">{
        if err != nil </span><span class="cov3" title="3">{
                isIpv6err = nsaddr.Is6()
                var ne net.Error
                ok := errors.Is(err, io.EOF)
                if errors.As(err, &amp;ne) </span><span class="cov1" title="1">{
                        ok = true
                }</span>
                <span class="cov3" title="3">ok = ok || errors.Is(err, os.ErrDeadlineExceeded) || errors.Is(err, context.DeadlineExceeded)
                ok = ok || errors.Is(err, syscall.ECONNREFUSED)
                errstr := err.Error()
                ok = ok || strings.Contains(errstr, "timeout") || strings.Contains(errstr, "refused")
                if ok </span><span class="cov3" title="3">{
                        var m map[netip.Addr]netError
                        switch protocol </span>{
                        case "udp":<span class="cov2" title="2">
                                isUdpErr = true
                                m = r.udperrs</span>
                        case "tcp":<span class="cov1" title="1">
                                m = r.tcperrs</span>
                        }
                        <span class="cov3" title="3">if m != nil </span><span class="cov3" title="3">{
                                r.mu.Lock()
                                m[nsaddr] = netError{Err: err, When: time.Now()}
                                r.mu.Unlock()
                        }</span>
                }
        }
        <span class="cov10" title="101">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package recursive

import (
        "context"
        "net/netip"
        "sync"
        "time"
)

type rootRtt struct {
        addr netip.Addr
        rtt  time.Duration
}

func timeRoot(ctx context.Context, r *Recursive, wg *sync.WaitGroup, rt *rootRtt) <span class="cov8" title="52">{
        defer wg.Done()
        const numProbes = 3
        network := "tcp4"
        if rt.addr.Is6() </span><span class="cov7" title="26">{
                network = "tcp6"
        }</span>
        <span class="cov8" title="52">rt.rtt = time.Hour
        var rtt time.Duration
        for i := 0; i &lt; numProbes; i++ </span><span class="cov10" title="100">{
                now := time.Now()
                conn, err := r.DialContext(ctx, network, netip.AddrPortFrom(rt.addr, 53).String())
                if err != nil </span><span class="cov7" title="29">{
                        return
                }</span>
                <span class="cov9" title="71">rtt += time.Since(now)
                _ = conn.Close()</span>
        }
        <span class="cov7" title="23">rt.rtt = rtt / numProbes</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
